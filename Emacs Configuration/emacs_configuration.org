* Notes and General Commands

Note that this is an experimentation integrating WSL on window emacs.

In general there are too many conflicts. The major ones discovered to
the point are the issues with "sudo orders". These cannot be properly
integrated in this WSL-Windows Emacs. Moreover this solution does not
manage to integrate properly git. Git repositories are not recognized
as such and difficulties arise when pulling and pushing.

Note however that when installing emacs on the Ubuntu partition and
calling emacs in that partition everything integrates well.

This is therefore a very nice and powerful feature and it suggest to
switch to this solution. 

** Reload this configuration file

Instead of closing and opening emacs back and forth when editing this
file configuration; you can simply reload the file using:

~M-x eval-buffer~

** Join/merge all the lines

   This is useful to counter the automatic indent in some cases. There
   is a function for this =join-line=

** Insert Image Directly

Use =C-u C-c C-l= to navigate directories and insert directly the
desired image.

** Replace Regex

 To replace all the text between =<<text>>= you can use:

 =M-x replace regex= and enter the following regular expression:

 =<<\(.*\)>>=

 For instance this replace the regular expression  =<< anything >>=.

 For testing your regular expression you might refer to [[https://www.debuggex.com/?flavor=python][this website]].

** Poor Performance

   Sometimes it might happen that emacs displays a poor performance
   and you are not satisfied with it. It recently happened to me on a
   very large org file with many closed org bullets. 

   In that case navigating through the file and skipping many lines
   was awfully slow. The solution in such case is to start an profile
   mode with =M-x profiler-start= do some operations, terminate the
   profiler =M-x profiler-stop= and finally by inspecting its results
   =M-x profiler-report=.

   It turned out that in that specific case the bottleneck was in the
   linum mode, that was taking an awful amount of time to recompute
   the lines displayed at every cursor change. Entering deeper in the
   org leafs the performance did in fact increase and stopping linum
   mode for the file was indeed the solution.

** On the mac install the trash-cli

Nice feature to be used instead of =rm=. You can read of it at the
[[https://github.com/andreafrancia/trash-cli][following page]].

** Magit diffing

Puahhh... That was a waste of time. I was trying to understand how to
view the edits between two commits as in ~git diff <commit 1> <commit
2>~.

It turned out that to do that you can simply go in the wip log via =l
RET l= once you are in the magit status. Then add the highlighting
marker. Go between the range you want to select and use the common
diff command =d=. If you are interested in checking the differences
for a specific file then you can simply use the ~=f~ option before
selecting the =d= one.

You can then enter the file path of the file you are interested in,
for instance =app/test/M001_tests/test_pdf.py=

A particular option in this sense is also the ediffing of two
files. This is particularly useful when you have changed something and
want to go back to the previous version but want to double check
quickly before what has changed/ just take some of the old features.

[[https://stackoverflow.com/questions/215718/how-can-i-reset-or-revert-a-file-to-a-specific-revision][How to revert a single file in git]].

To go back to a specific commit in your git history you can use ~git
checkout <commit>~. The commit can be easily found in the wip log
mentioned above.

** Save reference to other file

    The syntax is the following

    #+begin_example
    [[/path/to/file.php::line][string-to-display]]
    #+end_example


** References

   These are good fellows you can check from time to time what they
   are doing:

   - [[https://www.ict4g.net/adolfo/notes/emacs/emacs-caldav.html][fellow1]]


** For debugging

   You can use =toggle-debug-on-error= to see the backtrace and where
   your emacs functions fails.

   You can watch [[https://www.youtube.com/watch?v=odkYXXYOxpo][this crash course]].
   

* For Mac Specific Issues

#+BEGIN_SRC emacs-lisp
;; I set this at the beginning of my init.el for other mac specific settings
(defconst *is-a-mac* (eq system-type 'darwin))
#+END_SRC


* General sources

On the Mac I installed emacs following [[https://stackoverflow.com/questions/44092539/how-can-i-install-emacs-correctly-on-os-x][this instructions]]. The
recommended cask way was not working with imagemagick for me and this
was important to me.

#+begin_example
$ brew tap daviderestivo/emacs-head
$ brew install emacs-head --HEAD --with-cocoa --with-librsvg --with-imagemagick@7 --with-no-frame-refocus --with-mailutils --with-dbus --with-modules 	
#+end_example

Ok, suddenly my old emacs installed as above stopped working. I installed it again via cask.

#+begin_example
$ brew install --cask emacs
#+end_example

As a general resources for generating my emacs configuration I mainly
refer to [[https://cestlaz.github.io/tags/emacs/page/6/][emacs_intro_&packages]], [[https://github.com/hrs/dotfiles/blob/master/emacs/.emacs.d/configuration.org][Harry Schwartz emacs config]]. Harry
Schwartz shared a video on the internet containing a good introduction
to the org mode and suggested the option of writing the emacs
configuration file as =org= file as I am currently doing, which I
enjoy a lot and believe it gives a great overview over the document.

Another nice guy to follow is [[https://alhassy.github.io/init/][this one]].


* Increase cache allowed

From Howard Abraham...

With a long history of working on small machines without gigabytes of
RAM, we might as well let Emacs be the beast it has always dreamed.

First, letâ€™s increase the cache:

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 100000000)
#+END_SRC

Another interesting trick is to compile byte code. This will make the
code run faster.

You can do that by following the four instructions should you be
interested.

#+begin_example
- Start Emacs.
- Type [Alt]-x.
- When prompted for a command, enter byte-force-recompile [Enter].
- When prompted for a directory name, change the path to your =.el=
  files press [Enter].
#+end_example

The end result should be an .elc file for most of the =.el= files (not
all of the files will be compiled, so don't worry if some are
missing).


* Shortcut to Configuration File

This section creates a shortcut key to go to this =emacs=
configuration file without having to search for the directory.
#+BEGIN_SRC emacs-lisp
    (defun hrs/visit-emacs-config ()
      (interactive)
      (find-file "~/Desktop/emacs_config/Emacs Configuration/emacs_configuration.org"))

    (global-set-key (kbd "C-c e") 'hrs/visit-emacs-config)
#+END_SRC


* Ensure Use-package

This package assure that you do not have to download all of the
packages manually and it downloads all of the necessary packages
automatically and open them with the predefined configuration options.

Notice that you have downloaded ~(package-install)~ to your =.emacs=.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
(setq use-package-always-ensure t)
#+END_SRC


* Quelpa

Quelpa download

 #+begin_src emacs-lisp 
 (unless (package-installed-p 'quelpa)
     (with-temp-buffer
       (url-insert-file-contents "https://github.com/quelpa/quelpa/raw/master/quelpa.el")
       (eval-buffer)
       (quelpa-self-upgrade)))
 #+end_src 

 Use-package 
 #+begin_src emacs-lisp 
 (unless (package-installed-p 'quelpa-use-package)
   (quelpa
    '(quelpa-use-package
      :fetcher git
      :url "https://github.com/quelpa/quelpa-use-package.git"))
 )
 #+end_src 

 #+begin_src emacs-lisp 
 (require 'quelpa-use-package)
 #+end_src 

Recall that you can find the packages available in the emacsmirror by
using =epkg-list-packages= function.


* EmacsMirror

  Use epkg to check the available packages on emacsmirror

#+begin_src emacs-lisp 
;; first download the epkg
;;  git clone git@github.com:emacsmirror/epkgs.git ~/.emacs.d/epkgs

(use-package epkg
  :ensure t)
#+end_src 


* Make sure you can use standard lisp functions and macros

#+BEGIN_SRC emacs-lisp
  (require 'cl)
#+END_SRC


* Enable MELPA package manager

  #+BEGIN_SRC emacs-lisp
    (require 'package)
    (let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
			(not (gnutls-available-p))))
	   (proto (if no-ssl "http" "https")))
      ;; Comment/uncomment these two lines to enable/disable MELPA and MELPA Stable as desired
      (add-to-list 'package-archives (cons "melpa-stable" (concat proto "://stable.melpa.org/packages/")) t)
      (when (< emacs-major-version 24)
	;; For important compatibility libraries like cl-lib
	(add-to-list 'package-archives (cons "gnu" (concat proto "://elpa.gnu.org/packages/")))))
  #+END_SRC


* Enable Marmalade and Org ELPA package manager

Org ELPA
#+BEGIN_SRC emacs-lisp
  (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
#+END_SRC

Marmalade
#+BEGIN_SRC emacs-lisp
  (add-to-list 'package-archives '("marmalade" .  "http://marmalade-repo.org/packages/"))
#+END_SRC


* Basic Customization
** Mode Line


 Important for doom-modeline is to have =all the icons= installed and
 to run =M-x all-the-icons-install-fonts= one time.

 #+begin_src emacs-lisp 
 (use-package doom-modeline
   :ensure t
   :init
   (doom-modeline-mode 1))
 #+end_src 

 #+begin_src emacs-lisp 
 ;; How tall the mode-line should be. It's only respected in GUI.
 ;; If the actual char height is larger, it respects the actual height.
 (setq doom-modeline-height 1)
 ;; How wide the mode-line bar should be. It's only respected in GUI.
 (setq doom-modeline-bar-width 3)

 (setq doom-modeline-lsp t)
 (setq doom-modeline-project-detection 'project)
 #+end_src 

 #+begin_src emacs-lisp 
 (use-package powerline
   :ensure t)
 #+end_src 

** Image size

Imagemagick is missing.

#+begin_src emacs-lisp 
(setq org-image-actual-width nil)
#+end_src 

  The following does the following:

    => if there is a #+ATTR.*: width="200", resize to 200,
     otherwise resize to 600; this was chosen as it is a good display
     on my screen.

  #+begin_src emacs-lisp 
  (setq org-image-actual-width '(600))

;; (setq org-image-actual-width (/ (display-pixel-width) 3))
  #+end_src 

** Set global encoding 

#+BEGIN_SRC emacs-lisp
;; UTF-8 as default encoding
(set-language-environment "utf-8")
(prefer-coding-system 'utf-8)
(setq coding-system-for-read 'utf-8)
(setq coding-system-for-write 'utf-8)
#+END_SRC

** No beeps, scrollbar etc.

#+BEGIN_SRC emacs-lisp
(setq visible-bell t)             ;; Get rid of the beeps

(when (window-system)
  (tool-bar-mode 0)               ;; Toolbars were only cool with XEmacs
  (when (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))
  (scroll-bar-mode -1))            ;; Scrollbars are waste screen estate
#+END_SRC

** Highlight color

   Set highlight color when activate the "mark set" to be a different
   color than gray as it is poorly recognizable with the theme and the
   line highlighting mode.

#+BEGIN_SRC emacs-lisp
      (defun color-highlight ()
	(interactive)
	(set-face-attribute 'region nil :background "indian red" :foreground "grey5"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook #'color-highlight) ;; to actiavte it when starting emacs.
#+END_SRC

Create general function to set transparency.
#+BEGIN_SRC emacs-lisp
 ;; Set transparency of emacs
 (defun transparency (value)
   "Sets the transparency of the frame window. 0=transparent/100=opaque"
   (interactive "nTransparency Value 0 - 100 opaque:")
   (set-frame-parameter (selected-frame) 'alpha value))
#+END_SRC

** Two very handy tricks from Howard Abraham

   - Replace yes-no answers with y-n. 

   #+BEGIN_SRC emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   - Fix the scrolling =C-v= and =M-v= such that the cursor will
     return to the previous scrolling position if going down and up.

   #+BEGIN_SRC emacs-lisp
     (setq scroll-conservatively 10000
          scroll-preserve-screen-position t)
   #+END_SRC

** Undo Redo Tree 
   
   This is a very nice package that allows you to expand on the basics
   emacs undo functionalities. In emacs you can undo with =C-_= or
   =C-/=.

   The package undo-tre allows you to have the redo option with
   =C-?=.

   Moreover it allows you to visualize a tree with the changes you
   have done and to move interactively across it to go back to a given
   point in you history. 

   If you code something and then cancel that something and code
   something else, the undo tree will show a branch at this stage
   with the two versions of your edit.

   Require the package and enable it globally.

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
     :ensure t
     :init
     (global-undo-tree-mode))
   #+END_SRC

** Parenthesis

   Try this package for parenthesis highlighting. 

   Learn how to quickly operate with parenthesis using predit through
   the following link [[http://danmidwood.com/content/2014/11/21/animated-paredit.html][predit-tutorial.]]

   #+BEGIN_SRC emacs-lisp
   (use-package paredit
   :ensure t) 
   (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
   #+END_SRC

   Despite being super useful paredit unfortunately conflicts with the
   usual <DEL>. This will not allow to cancel entire chunks of
   highlighted text. Set another key binding for paredit delete.

   Notice the code below removes the paredit delete altogether because
   I do not find it that useful. Another option would just to add
   another line shifting the paredit =<DEL>= to some other key binding. 

#+BEGIN_SRC emacs-lisp
  (eval-after-load "paredit" '(define-key paredit-mode-map (kbd "<DEL>") nil))

  (add-hook 'org-mode-hook 'enable-paredit-mode) ;; notice at the moment paredit is just bound to org-mode. Expand it.
#+END_SRC


Rainbow-delimiters is convenient for coloring matching
parentheses. Now if a parentheses is not matched it will be colored
red when placing the cursor on the parenthesis.

    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-delimiters)  
      (add-hook 'prog-mode-hook 'rainbow-delimiters-mode) ;; to enable it in all programming-related modes
      (set-face-attribute 'rainbow-delimiters-unmatched-face nil
		  :foreground "red"
		  :inherit 'error
		  :box t)
   #+END_SRC

    Highlight parenthesis stuff inside it if u are before or after it.

    #+begin_src emacs-lisp 
    (show-paren-mode t)
    (setq show-paren-style 'expression)
    #+end_src 

** Kill current buffer and close its window

#+BEGIN_SRC emacs-lisp
    ;; Always kill current buffer with "C-x k"
    (defun bjm/kill-this-buffer ()
      "Kill the current buffer."
      (interactive)
      (kill-buffer (current-buffer))
      (delete-window))

    (global-set-key (kbd "C-x k") 'bjm/kill-this-buffer)
#+END_SRC

In case you want to select as standard which buffer to kill
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x K") 'kill-buffer)
#+END_SRC

** Save cursor current position when killing the file

   Using save-place-mode saves the location of point for every file I
   visit. If I close the file or close the editor, then later re-open
   it, point will be at the last place I visited.

#+BEGIN_SRC emacs-lisp
    (save-place-mode t)
#+END_SRC

** Highlight current line

#+BEGIN_SRC emacs-lisp
 (global-hl-line-mode +1)
#+END_SRC

** Inhibit start up messages

#+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-message t);; this will hide the initial tutorial
#+END_SRC

*** Remove Other start up buffers

#+BEGIN_SRC emacs-lisp
    ;; Makes *scratch* empty.
    (setq initial-scratch-message "")

    ;; Removes *scratch* from buffer after the mode has been set.
    (defun remove-scratch-buffer ()
      (if (get-buffer "*scratch*")
	  (kill-buffer "*scratch*")))
    (add-hook 'after-change-major-mode-hook 'remove-scratch-buffer)
#+END_SRC

Uncomment the next buffer if you want to inhibit start up messages and
kill the buffer. 

#+BEGIN_SRC emacs-lisp
    ;; Removes *messages* from the buffer.
    ;;(setq-default message-log-max nil)
    ;;(kill-buffer "*Messages*")
#+END_SRC

** Theme

*Reminder:* Check the face you are for adapting the colors by using
/C-u C-x =/ this is binded to =describe-faces=.

*Reminder:* Notice also that particularly interesting is the option to
run =M-x customize face=. There you can enter the face you aim to
customize, for instance the =org-level-1= variable. With enter you can
then see the autocompletion for the for the entered words.

You can then check  if there is any annoying default value or so.
You can moreover edit this directly in the tab making such boring
configurations quick.

*Important:* It is also possible to leverage the =M-x
list-faces-display= that shows all the faces use in your emacs session
and you can then correspondingly search there fore the face you are
interested into modify.

*** Configurations for all themes


    Notice this first is necessary in order to allow your modifications to the themes colours

#+begin_src emacs-lisp 
(setq custom--inhibit-theme-enable nil)
#+end_src 

    Notice that below is some general modification.
    
#+begin_src emacs-lisp 
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 ;; '(alect-title ((t (:foreground "#077707" :weight bold :height 2.0))))
 '(bold ((t (:weight bold))))
 '(cursor ((t (:background "white" :foreground "white" :inverse-video t))))
 '(flyspell-duplicate ((t (:background "gray16" :foreground "khaki3" :underline (:color foreground-color :style wave)))))
 '(flyspell-incorrect ((t (:foreground "#d81212" :underline (:color "#F92672" :style wave)))))
 '(magit-section-highlight ((t (:background nil))))
 '(magit-section-heading ((t (:inherit nil :box (:line-width 2 :color "black" :style released-button) :weight bold :height 1.5))))
 '(org-agenda-structure((t (:background nil :foreground nil))))
 '(org-agenda-date ((t (:inherit nil :background nil :foreground nil :inverse-video nil :box (:line-width 2 :color "#272822") :overline nil :slant normal :weight normal :height 1.0))))
 '(org-agenda-date-today ((t (:inherit org-agenda-date :background nil :foreground nil :inverse-video nil  :overline nil :weight bold))))
 '(org-agenda-date-weekend ((t (:foreground nil :inverse-video nil :overline nil :underline nil))))
 '(org-document-title ((t (:inherit alect-title :foreground "#F8F8F0" :weight bold :height 0.7))))
 '(org-level-1 ((t (:height 1.4))))
 '(org-level-2 ((t (:height 1.25))))
 '(org-level-3 ((t  nil ))
 '(org-meta-line ((t (:background nil :inherit nil)))))
)
#+end_src 

*** Doom Theme

#+begin_src emacs-lisp 
  (defun dark/doom ()
    (interactive)
    (use-package doom-themes
      :config
      ;; Global settings (defaults)
      (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
	    doom-themes-enable-italic t) ; if nil, italics is universally disabled
      (load-theme 'doom-peacock t)

      ;; Enable flashing mode-line on errors
      (doom-themes-visual-bell-config)

      ;; Enable custom neotree theme (all-the-icons must be installed!)
      ;; (doom-themes-neotree-config)
      ;; or for treemacs users
      ;; (setq doom-themes-treemacs-theme "doom-colors") ; use the colorful treemacs theme
      ;; (doom-themes-treemacs-config)

      ;; Corrects (and improves) org-mode's native fontification.
      (doom-themes-org-config)
      )
  )
#+end_src 

*** Load Monokai theme as standard theme
    
#+begin_src emacs-lisp 
(defun dark/monokai ()
  (interactive)
  (use-package monokai-theme
    :ensure t)

  (load-theme 'monokai t) ;; load the black monokai theme

  (with-eval-after-load "monokai-theme"
    (custom-theme-set-faces
     'monokai
     '(default ((t)))
     '(org-block-begin-line
       ((t (:background:"#35331D" :foreground "#75715E" ))))
     '(org-block
       ((t (:background "#3E3D31" :foreground "#F8F8F0"))))  
     '(org-block-end-line
       ((t (:background:"#35331D" :foreground "#75715E" ))))
     '(font-lock-builtin-face
       ((t :foreground "cornflower blue"))) ;; this is the foreground for instance

     ;; Change color of the org headers
     '(org-level-1 ((t (:foreground "spring green" :inherit nil))))
     '(org-level-2 ((t (:foreground "light blue" :inherit nil))))
     '(org-level-3 ((t (:foreground "indian red" :inherit nil))))

     ;; font shell
     '(font-lock-face
       ((t (:foreground "white" :inherit nil :background nil))))

     '(term
       ((t (:foreground "white" :inherit nil :background nil))))
     )
  )
)
#+end_src 

#+RESULTS:
: dark/monokai

    Change line highlighting color for monokai. At the moment I could not
    find a nice option. But it annoys me that in org chunck it becomes
    almost indistinguishable. Maybe one day you will find the right
    color...
    
#+BEGIN_SRC emacs-lisp
      ;; (set-face-background 'hl-line "rosy brown")

      ;; ;To keep syntax highlighting in the current line:

      ;; (set-face-foreground 'highlight nil)
#+END_SRC

*** Use light theme for bright light

    Define function for customizing light theme with the colors you
    want. 

    Define global function that you can call to get the brighter theme.

    #+BEGIN_SRC emacs-lisp
    (defun bright/light ()
      (interactive)
      (use-package alect-themes
	:ensure t)

      (load-theme 'alect-light t) 

       (with-eval-after-load  "alect-light-theme"
	 (custom-theme-set-faces
	  'alect-light
	  ;;'(default ((t)))
	  ;; Change the color of the org chunks.
	  '(org-block-begin-line
	    ((t (:underline "#A7A6AA" :foreground "#008ED1" :background nil))))
	  '(org-block
	    ((t (:background "snow3" :inherit nil))))  
	  '(org-block-end-line
	    ((t (:overline "#A7A6AA" :foreground "#008ED1" :background nil))))
	  '(org-quote
	    ((t (:background "snow3" :inherit nil))))
	  '(org-meta-line
	    ((t (:inherit nil))))

	  ;; Change color of the org headers
	  '(org-level-1 ((t (:foreground "indian red"))))
	  '(org-level-2 ((t (:foreground "#008ED1"))))
	  '(org-level-3 ((t (:foreground "sea green"))))
	  '(org-level-4 ((t (:foreground "salmon3"))))

	  ;; Change color of org references
	  '(org-ref-cite-face
	    ((t (:foreground "#008ED1" :inherit nil))))

	  ;; Change color of properties tags
	  '(org-drawer
	    ((t (:foreground "salmon3" :inherit nil))))

	  ;; Change color of org date
	  '(org-date
	    ((t (:foreground "dark cyan" :inherit nil))))

	  ;; magit text for committing
	  '(git-commit-summary
	    ((t (:foreground "black" :inherit nil))))

	  ;; Specify the colors of strings etc...
	  '(font-lock-comment-face ((t :foreground "SeaGreen4"))) 
	  '(font-lock-builtin-face  ((t :foreground "blue"))) ;; this is the foreground for instance
	  '(font-lock-string-face  ((t :foreground "indian red"))) ;; this is the commentary and strings. Use it for custom set faces when you know it.

	  ;; Change color of ein input cells
	  '(ein:cell-input-area
	    ((t (:background "snow3" :inherit nil))))

	  ;; Change color of dired - i.e. of files appearing to the left
	  '(diredp-file-name
	    ((t (:foreground "indian red" :inherit nil))))
	  '(diredp-dir-name
	    ((t (:foreground "blue" :inherit nil))))

	  ;; markdown face for lsp server
	  ;; Change color of ein input cells
	  '(markdown-code-face
	    ((t (:background nil :inherit nil))))

	  ;; Flyspell duplicate - mild error
	  '(flyspell-duplicate
	    ((t (:background nil :inherit nil :foreground "DarkOrange2"))))

	  ;; Chnage color of global lining
	  '(linum
	    ((t (:background "light grey" :inherit nil))))

	  ;; Change the color in the minibuffer prompt to read better
	  '(minibuffer-prompt
	    ((t (:background "white" :inherit nil :foreground "indian red"))))

	  ;; Change the color in the minibuffer prompt to read better
	  '(alect-block
	    ((t (:background nil :inherit nil))))

	  ;; Org link
	  '(org-link
	    ((t (:foreground "blue" :inherit nil))))

	  ;; Org-block
	  '(org-block
	    ((t (:foreground "light-grey" :background "grey78" :inherit nil))))

	  ;; Shell Prompt
	  '(term
	    ((t (:foreground "black" :inherit nil))))
	  '(comint-highlight-prompt 
	    ((t (:foreground "#008ED1"))))
	  
	  ;; Dired
	  '(dired-directory
	    ((t (:foreground "blue"))))
	  '(diredp-file-suffix
	    ((t (:foreground "black"))))


	  ;; for python indents
	  '(highlight-indentation-face
	    ((t (:background "grey85"))))

	  ;; css property
	  '(css-property
	    ((t (:foreground "dark green"))))

	  ;; magit
	  '(magit-diff-file-heading
	    ((t (:foreground "sea green"))))

	  '(magit-filename
	    ((t (:foreground "indian red"))))
	  )
	 )
      )
    #+END_SRC

    #+RESULTS:
    : bright/light

*** Misterioso

#+begin_src emacs-lisp 
(defun dark/misterioso ()
  (interactive)
  (load-theme 'misterioso)
  ;; (with-eval-after-load "misterioso-theme"
  ;;   (custom-theme-set-faces
  ;;    'misterioso
  ;;    '(default ((t)))
  ;;    (set-face-background 'linum "#2d3743")
  ;;    (set-face-background 'hl-line "#212931")
  ;;    '(org-block
  ;;      ((t (:background "#3E3D31" :foreground "#F8F8F0"))))
  ;;    '(ivy-subdir
  ;;      ((t (:foreground "#ffad29" ))))
  ;;  )
  ;; )
)
#+end_src 

#+RESULTS:
: dark/misterioso

#+begin_src emacs-lisp 
 ;; there is a weird behaviour with the org-agenda. 
 ;; consider incorportaing such changes.
 
 ;; '(org-agenda-date ((t (:background nil :foreground nil :inverse-video nil :box (:line-width 2 :color nil) :overline nil :slant normal :weight normal :height 1.0))))
 ;; '(org-agenda-date-today ((t (:inherit org-agenda-date :foreground nil :background nil)))) 
 ;; '(org-agenda-date-weekend ((t (:inherit org-agenda-date :foreground nil  :background nil))))
#+end_src 

*** Make them available as classes

#+begin_src emacs-lisp 
(defvar a 3 "Initial setting for the `a` global variable.")
#+end_src 

 #+begin_src emacs-lisp 
(defun my-switch ()
"Doc-string for `my-switch` function."
(interactive)
  (cond
    ((= a 1)
      (call-interactively 'dark/monokai)
      (message "set monokai")
      (setq a 2))
    ((= a 2)
      (call-interactively 'dark/doom)
      (message "set doom")
      (setq a 3))
    ((= a 3)
      (call-interactively 'dark/misterioso)
      (message "set misterioso")
      (setq a 4)) 
    ((= a 4)
      (call-interactively 'bright/light)
      (message "set bright-light")
      (setq a 1))) )
#+end_src 

#+begin_src emacs-lisp 
(global-set-key (kbd "s-b") 'my-switch)
#+end_src 


** Set lining globally

   #+BEGIN_SRC emacs-lisp
(global-linum-mode t) ;; load line number at the beginning of the
		      ;; file. Notice the global argument means that
		      ;; this line configuration will apply to all
		      ;; buffers in emacs. You can also enable things
		      ;; per mode - e.g., python-mode, markdown-mode,
		      ;; text-mode.
      
#+END_SRC

** Moving across windows

#+BEGIN_SRC emacs-lisp
(defun ace/window ()
  (interactive)
  (use-package ace-window
     :ensure t
     :init
     (progn
       (global-set-key (kbd "C-x s-o") 'ace-window)
       (custom-set-faces
	'(aw-leading-char-face
	  ((t (:inherit ace-jump-face-foreground :height 3.0)))))
       ))
)

(ace/window)
#+END_SRC

#+RESULTS:

To move across windows holding the shift key

#+BEGIN_SRC emacs-lisp
(windmove-default-keybindings)

;; Make windmove work in Org mode:
(add-hook 'org-shiftup-final-hook 'windmove-up)
(add-hook 'org-shiftleft-final-hook 'windmove-left)
(add-hook 'org-shiftdown-final-hook 'windmove-down)
(add-hook 'org-shiftright-final-hook 'windmove-right)
#+END_SRC

** Hungry mode
*** Smart hungry mode

    Try to use the smart-hungry-delete that sets the global keys
    explicitly.

    Download the package manually from [[https://github.com/hrehfeld/emacs-smart-hungry-delete][smart_hungry-github]]. Could not
    find the package on MELPA.

 #+BEGIN_SRC emacs-lisp
   (add-to-list 'load-path "/Users/marcohassan/.emacs.d/emacs-smart-hungry-delete/")
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
  (load "smart-hungry-delete")
 #+END_SRC 

   Add forward hungry deletion

 #+BEGIN_SRC emacs-lisp
   (smart-hungry-delete-add-default-hooks)
   (global-set-key (kbd "C-c d") 'smart-hungry-delete-forward-char)
   (global-set-key (kbd "C-c <backspace>") 'smart-hungry-delete-backward-char)
 #+END_SRC

** Expand region

   This package allows you to expand the highlighting from inside to
   outside. That is from the inner most layer to the layers above. For
   instance if you are into a parenthesis it will allow you to expand
   from letter to word, to the entire parenthesis, function, etc.

#+BEGIN_SRC emacs-lisp
  ;; (use-package expand-region
  ;;   :ensure t 
  ;;   :config
  ;;   (global-set-key (kbd "C-*") 'er/expand-region)
  ;; )
#+END_SRC

New version of expand region. Try it and see which one you like better

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :config
  (defun ha/expand-region (lines)
    "Prefix-oriented wrapper around Magnar's `er/expand-region'.

Call with LINES equal to 1 (given no prefix), it expands the
region as normal.  When LINES given a positive number, selects
the current line and number of lines specified.  When LINES is a
negative number, selects the current line and the previous lines
specified.  Select the current line if the LINES prefix is zero."
    (interactive "p")
    (cond ((= lines 1)   (er/expand-region 1))
          ((< lines 0)   (ha/expand-previous-line-as-region lines))
          (t             (ha/expand-next-line-as-region (1+ lines)))))

  (defun ha/expand-next-line-as-region (lines)
    (message "lines = %d" lines)
    (beginning-of-line)
    (set-mark (point))
    (end-of-line lines))

  (defun ha/expand-previous-line-as-region (lines)
    (end-of-line)
    (set-mark (point))
    (beginning-of-line (1+ lines)))

  :bind ("C-*" . ha/expand-region))
#+END_SRC

** Autofill Mode

Goes to next line on the next space when the line becomes too wide.

#+BEGIN_SRC emacs-lisp
;;  (setq-default auto-fill-function 'do-auto-fill)

   (add-hook 'org-mode-hook 'turn-on-auto-fill)

;;  go to next line but in a horrible way at this stage. try to fix
;;  the issue.
#+END_SRC

To set the width of the column for which the entry must go to the new
line, check at the following [[https://www.emacswiki.org/emacs/FillParagraph][page]].

** Beacon Mode

   This emits a short light when the you move your cursor around the
   screen in a fast way. That should help you to quickly identify
   where your cursor is and not to get lost when quickly scrolling on
   the screen.

   You can set in the parameter for deciding when the beacon should
   work. Moreover, you define how long the light should flash. For
   this and several other options check at the github repo [[https://github.com/Malabarba/beacon][beacon]].

#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t 
    :config
    (beacon-mode 1)
    (setq beacon-color "#50D050") ;; a light green
   )
#+END_SRC

   Work nicely. Seems to slow emacs though. Try to observe on the long
   run if it slows it sensibly and remove it if this is the case. 

** Unfill paragraph

   Might be good. For instance for canceling all of the paragraph quickly
   or for commenting it away.

   #+BEGIN_SRC emacs-lisp
   (defun unfill-paragraph ()
      "Convert a multi-line paragraph into a single line of text."
      (interactive)
      (let ((fill-column (point-max)))
        (fill-paragraph nil)))

    ;; Handy key definition
    (define-key global-map "\M-Q" 'unfill-paragraph)
   #+END_SRC

** Aggressive Indent

   Automatically indents all of your code. 

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
  :ensure t)

  (global-aggressive-indent-mode)
#+END_SRC

** Set Default Size for all Buffers

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :height 180)
#+END_SRC

** Bash Autocomplete

Did not like it too much. 

   #+BEGIN_SRC emacs-lisp
   ;; (use-package bash-completion
   ;;  :ensure t)
   #+END_SRC

#+begin_src emacs-lisp 
;; (autoload 'bash-completion-dynamic-complete 
;;   "bash-completion"
;;   "BASH completion hook")
;; (add-hook 'shell-dynamic-complete-functions
;;   'bash-completion-dynamic-complete)
#+end_src 

You can still ameliorate the autocompletion. You have to look on the
github page for the package for that.

** Sidebar

Check at the configuration on [[https://github.com/jojojames/dired-sidebar/issues/26][this thread]]. There might be still
interesting content there.

*** Sidebar config

 Show the repo structure in a similar way to VScode. Incompact on
 Melpa.

 #+begin_src emacs-lisp 
 ;; (use-package dired-sidebar
 ;;   :bind (("C-x C-n" . dired-sidebar-toggle-sidebar))
 ;;   :ensure t
 ;;   :commands (dired-sidebar-toggle-sidebar)
 ;;   :init
 ;;   (add-hook 'dired-sidebar-mode-hook
 ;;             (lambda ()
 ;;               (unless (file-remote-p default-directory)
 ;;                 (auto-revert-mode))))
 ;;   :config
 ;;   (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
 ;;   (push 'rotate-windows dired-sidebar-toggle-hidden-commands)

 ;;   (setq dired-sidebar-subtree-line-prefix "__")
 ;;   (setq dired-sidebar-theme 'vscode)
 ;;   (setq dired-sidebar-use-term-integration t)
 ;;   (setq dired-sidebar-use-custom-font t))
 #+end_src 

 : dired-sidebar-toggle-sidebar

 Was downloaded through git following the instruction on the [[https://github.com/jojojames/dired-sidebar][github
 repo]] in the meanwhile.

 #+begin_src emacs-lisp 
 (add-to-list 'load-path "/Users/marcohassan/.emacs.d/dired-sidebar")
 (add-to-list 'load-path "/Users/marcohassan/.emacs.d/dired-hacks")
 #+end_src  

 #+begin_src emacs-lisp 
 (load "dired-sidebar")
 #+end_src 
 : t

 Configuration

 #+begin_src emacs-lisp 
 (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
 (push 'rotate-windows dired-sidebar-toggle-hidden-commands)
 
 ;; (setq dired-sidebar-subtree-line-prefix "__")
 (setq dired-sidebar-theme 'vscode)
 (setq dired-sidebar-use-term-integration t)
 (setq dired-sidebar-use-custom-font t)
 #+end_src 

Also change the default sidebar width.

#+begin_src emacs-lisp 
(setq dired-sidebar-width 20)
#+end_src 

Enlarge dired-sidebar

#+begin_src emacs-lisp 
(defun enlarge_sidebar()
  "Convert a multi-line paragraph into a single line of text."
  (interactive)
   (dired-sidebar-toggle-sidebar)
   (setq dired-sidebar-width (+ 5 dired-sidebar-width))
   (dired-sidebar-toggle-sidebar)
  )


(defun shrink_sidebar()
  "Convert a multi-line paragraph into a single line of text."
  (interactive)
   (dired-sidebar-toggle-sidebar)
   (setq dired-sidebar-width (- dired-sidebar-width 5))
   (dired-sidebar-toggle-sidebar)
  )

(defun default_sidebar()
  "Convert a multi-line paragraph into a single line of text."
  (interactive)
   (dired-sidebar-toggle-sidebar)  
   (setq dired-sidebar-width 20)
   (dired-sidebar-toggle-sidebar)   
  )

;; bind the two in dired mode
(add-hook 'dired-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c <") 'shrink_sidebar)
            (local-set-key (kbd "C-c >") 'enlarge_sidebar)
	    (local-set-key (kbd "C-c C-d") 'default_sidebar))
	  )
#+end_src 

#+RESULTS:
| (lambda nil (local-set-key (kbd C-c <) 'shrink_sidebar) (local-set-key (kbd C-c >) 'enlarge_sidebar) (local-set-key (kbd C-c C-d) 'default_sidebar)) | diredp-nb-marked-in-mode-name | diredp--set-up-font-locking | dired-extra-startup | (lambda nil (local-set-key (kbd C-c <) 'shrink_sidebar) (local-set-key (kbd C-c >) 'enlarge_sidebar)) | doom-modeline-set-project-modeline |

 #+begin_src emacs-lisp 
 (global-set-key (kbd "C-x C-n") 'dired-sidebar-toggle-sidebar)
 #+end_src 

*** Required Vscode icons

Also vscode icons not available to this stage

#+begin_src emacs-lisp 
;; (use-package vscode-icon
;;   :ensure t)
#+end_src 

Do it again the github way.

#+begin_src emacs-lisp 
(add-to-list 'load-path "/Users/marcohassan/.emacs.d/vscode-icon-emacs")
#+end_src 

#+begin_src emacs-lisp 
(load "vscode-icon")
#+end_src 

** Buffers

   Switch to most recent visited buffer

   #+begin_src emacs-lisp 
   (global-set-key (kbd "C-c M-<")  'mode-line-other-buffer)
   #+end_src 

** Transpose Buffers

 Change the order of the buffers.

 #+begin_src emacs-lisp 
 (defun transpose-buffers (arg)
   "Transpose the buffers shown in two windows."
   (interactive "p")
   (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
     (while (/= arg 0)
       (let ((this-win (window-buffer))
             (next-win (window-buffer (funcall selector))))
         (set-window-buffer (selected-window) next-win)
         (set-window-buffer (funcall selector) this-win)
         (select-window (funcall selector)))
       (setq arg (if (plusp arg) (1- arg) (1+ arg))))))
 #+end_src 

** Switch Frames

 Switches the content of the frames in the two monitors.

 #+begin_src emacs-lisp 
 (defun switch-buffers-between-frames ()
   "switch-buffers-between-frames switches the buffers between the two last frames"
   (interactive)
   (let ((this-frame-buffer nil)
	 (other-frame-buffer nil))
     (setq this-frame-buffer (car (frame-parameter nil 'buffer-list)))
     (other-frame 1)
     (setq other-frame-buffer (car (frame-parameter nil 'buffer-list)))
     (switch-to-buffer this-frame-buffer)
     (other-frame 1)
     (switch-to-buffer other-frame-buffer)))
 #+end_src 

** Toggle Split

#+begin_src emacs-lisp 
(use-package transpose-frame
  :ensure t)
#+end_src 

#+begin_src emacs-lisp 
(global-set-key (kbd "C-c 0") 'transpose-frame)
#+end_src 

** Wrap text in quotes


   #+begin_src emacs-lisp 
   (global-set-key (kbd "M-\"") 'insert-pair)
   #+end_src 

** Always split vertically

#+begin_src emacs-lisp 
(setq split-height-threshold nil)
(setq split-width-threshold 160)
#+end_src 

** Ibuffer

[[https://emacs.stackexchange.com/questions/2181/ibuffer-how-to-automatically-create-groups-per-project][This link might still be interesting to look at]].

#+begin_src emacs-lisp 
(setq ibuffer-saved-filter-groups
      (quote (("default"

	       ("terminal"  (or
                             (mode . term-mode)
                             (mode . shell-mode)
                             (mode . eshell-mode)
                             ))	       

               ("sidebar" (mode . dired-sidebar-mode))

               ("org" (mode . org-mode))

               ("python" (or
			  (mode . python-mode)
			  (mode . inferior-python-mode)
                          (name . "^\\*ob-ipython.*")
			  ))

               ("ein"    (name . "^\\*ein.*"))

               ("JSON"    (mode . json-mode))

	       ("magit"  (or
                             (mode . magit-mode)
                             (mode . magit-diff-mode)
                             (mode . magit-process-mode)
			     (name . "^magit.*")
                             ))

	       ("tramp"
		       (name . "^\\*tramp.*"))

	       ("LSP" (or
		       (name . "^\\*lsp.*")
		       (name . "^\\*pyls.*")
		       )
		)

	       ("Ediffing" (or
			    (name . "^\\*ediff.*")
			    (name . "^\\*Ediff.*")
			    )
		)

	       ("PDFs"      (mode . pdf-view-mode))

               ("planner" (or
                           (name . "^\\*Calendar\\*$")
                           (name . "^diary$")
                           (mode . muse-mode)))
               ("emacs" (or
                         (name . "^\\*scratch\\*$")
                         (name . "^\\*Messages\\*$")
			 ))

               ("dired" (mode . dired-mode))

               ("latex" (mode . latex-mode))

               ("gnus" (or
                        (mode . message-mode)
                        (mode . bbdb-mode)
                        (mode . mail-mode)
                        (mode . gnus-group-mode)
                        (mode . gnus-summary-mode)
                        (mode . gnus-article-mode)
                        (name . "^\\.bbdb$")
                        (name . "^\\.newsrc-dribble")))
	       )
	      )
	     )
)
#+end_src 

#+begin_src emacs-lisp 
(add-hook 'ibuffer-mode-hook
          (lambda ()
            (ibuffer-switch-to-saved-filter-groups "default")))
#+end_src 


#+begin_src emacs-lisp 
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src 

#+begin_src emacs-lisp 
(defun ibuffer-collapse-all-filter-groups ()
  "Collapse all filter groups at once"
  (interactive)
  (setq ibuffer-hidden-filter-groups
        (mapcar #'car (ibuffer-current-filter-groups-with-position)))
  (ibuffer-update nil t))
#+end_src 

#+begin_src emacs-lisp 
(eval-after-load 'ibuffer'
  (define-key ibuffer-mode-map (kbd "C-c C-c")   'ibuffer-collapse-all-filter-groups) 
)
#+end_src 

#+begin_src emacs-lisp 
(defun ibuffer-expand-all-filter-groups ()
  "Expand all filter groups at once"
  (interactive)
  (setq ibuffer-hidden-filter-groups nil)
  (ibuffer-update nil t))
#+end_src 

#+begin_src emacs-lisp 
(eval-after-load 'ibuffer'
  (define-key ibuffer-mode-map (kbd "C-c C-e")  'ibuffer-expand-all-filter-groups) 
)
#+end_src 


* Swiper for incremental search

Swiper allows you to easily leverage regular expressions. By entering
a the beginning of a word a space and some other parts of the next
world it will automatically search two words pairs each containing the
expression entered.

Before compiling the code below remember to install through melpa both
swiper as counsel.

#+BEGIN_SRC emacs-lisp
;; it looks like counsel is a requirement for swiper
(use-package counsel
:ensure t
)

(use-package swiper
:ensure try
:config
(progn
(ivy-mode 1)
(setq ivy-use-virtual-buffers t)
(global-set-key "\C-s" 'swiper)
(global-set-key (kbd "C-c C-r") 'ivy-resume)
(global-set-key (kbd "<f6>") 'ivy-resume)
(global-set-key (kbd "M-x") 'counsel-M-x)
(global-set-key (kbd "C-x C-f") 'counsel-find-file)
(global-set-key (kbd "<f1> f") 'counsel-describe-function)
(global-set-key (kbd "<f1> v") 'counsel-describe-variable)
(global-set-key (kbd "<f1> l") 'counsel-load-library)
(global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
(global-set-key (kbd "<f2> u") 'counsel-unicode-char)
(global-set-key (kbd "C-c g") 'counsel-git)
(global-set-key (kbd "C-c j") 'counsel-git-grep)
(global-set-key (kbd "C-c k") 'counsel-ag)
(global-set-key (kbd "C-x l") 'counsel-locate)
(global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
(define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
))
#+END_SRC


* Auto completion of words

To automatically advice on auto-completion given the words used in the
buffer.

** Company

*** General set up.

Try with company mode. Company mode integrates with flyspell in
org-mode and it is there chosen as the default auto-completion mode
for the org-mode.
#+Name: Company-auto-complete
#+BEGIN_SRC emacs-lisp
(use-package company
  :config
  (setq company-minimum-prefix-length 3)
  ;; (setq company-dabbrev-downcase 0) ;; I noted that company is particularly slow in suggesting auto-completion words in comparison to auto-complete. 
  (setq company-idle-delay 0)       ;; The below code was suggested on the internet to speed company suggestion up and is tried now.
  (global-company-mode t)                                  ;(add-hook 'org-mode-hook 'company-mode)
  )
#+END_SRC

The performance of company increased a lot with the two global options.

*** Company box
    For having fancy icons associated with different functions/variables
    etc.. Works nice with the quickhelp. Breaks smth in the front-end...

     #+begin_src emacs-lisp 
     ;; (use-package company-box
     ;;   :quelpa (company-box :fetcher github :repo "emacsmirror/company-box")
     ;;   :hook (company-mode . company-box-mode))
     #+end_src 


    #+begin_src emacs-lisp 
    (require 'all-the-icons)
    #+end_src 

*** Company quickhelp


This basically has the same functionality of the company box
above. The front end is not the best but better than company box.  If
you fix company box at some point I guess that would be beneficial.

this is also nice. But it breaks some autocompletion functionality
with the company cycle below. Keep it away for now and check later if
you do want to integrate it.

#+begin_src emacs-lisp 
;; (use-package company-quickhelp
;;   :ensure t
;;   :init 
;;   (company-quickhelp-mode))
#+end_src 

*** Synchronize company with pcomplete for org mode 

    Pcomplete integrates company such that when editing headers,
    processes, title and author and any other options in org mode
    starting with =#+= it will list all of the available options.

#+BEGIN_SRC emacs-lisp
(defun trigger-org-company-complete ()
  "Begins company-complete in org-mode buffer after pressing #+ chars."
  (interactive)
  (if (string-equal "#" (string (preceding-char)))
    (progn
      (insert "+")
      (company-complete))
    (insert "+")))

(eval-after-load 'org '(define-key org-mode-map
               (kbd "+") 'trigger-org-company-complete))
#+END_SRC

*** Company cycle through

Very handy way to work with company such that you do not have to enter
the word you are interested in with the =RET= command but can rather
cycle through them with the =TAB= command. This will autocomplete the
word and you can then continue writing with the space.

Link for this handy tool: [[https://gist.github.com/aaronjensen/a46f88dbd1ab9bb3aa22][cycle_company]].

 #+BEGIN_SRC emacs-lisp

 ;; Modify company so that tab and S-tab cycle through completions without
 ;; needing to hit enter.

 (defvar-local company-simple-complete--previous-prefix nil)
 (defvar-local company-simple-complete--before-complete-point nil)

 (defun company-simple-complete-frontend (command)
   (when (or (eq command 'show)
	      (and (eq command 'update)
		   (not (equal company-prefix company-simple-complete--previous-prefix))))
     (setq company-selection -1
	    company-simple-complete--previous-prefix company-prefix
	    company-simple-complete--before-complete-point nil)))

 (defun company-simple-complete-next (&optional arg)
   (interactive "p")
   (company-select-next arg)
   (company-simple-complete//complete-selection-and-stay))

 (defun company-simple-complete-previous (&optional arg)
   (interactive "p")
   (company-select-previous arg)
   (company-simple-complete//complete-selection-and-stay))

 (defun company-simple-complete//complete-selection-and-stay ()
   (if (cdr company-candidates)
	(when (company-manual-begin)
	  (when company-simple-complete--before-complete-point
	    (delete-region company-simple-complete--before-complete-point (point)))
	  (setq company-simple-complete--before-complete-point (point))
	  (unless (eq company-selection -1)
	    (company--insert-candidate (nth company-selection company-candidates)))
	  (company-call-frontends 'update)
	  (company-call-frontends 'post-command))
     (company-complete-selection)))

 (defadvice company-set-selection (around allow-no-selection (selection &optional force-update))
   "Allow selection to be -1"
   (setq selection
	  ;; TODO deal w/ wrap-around
	  (if company-selection-wrap-around
	      (mod selection company-candidates-length)
	    (max -1 (min (1- company-candidates-length) selection))))
   (when (or force-update (not (equal selection company-selection)))
     (setq company-selection selection
	    company-selection-changed t)
     (company-call-frontends 'update)))

 (defadvice company-tooltip--lines-update-offset (before allow-no-selection (selection _num-lines _limit))
   "Allow selection to be -1"
   (when (eq selection -1)
     (ad-set-arg 0 0)))

 (defadvice company-tooltip--simple-update-offset (before allow-no-selection (selection _num-lines limit))
   "Allow selection to be -1"
   (when (eq selection -1)
     (ad-set-arg 0 0)))

 (with-eval-after-load 'company
   (define-key company-active-map [tab] 'company-simple-complete-next)
   (define-key company-active-map (kbd "TAB") 'company-simple-complete-next)
   (define-key company-active-map (kbd "<S-tab>") 'company-simple-complete-previous)
   (define-key company-active-map (kbd "RET") nil)
   (define-key company-active-map (kbd "<return>") nil)

   (put 'company-simple-complete-next 'company-keep t)
   (put 'company-simple-complete-previous 'company-keep t)
   (setq company-require-match nil)
   (ad-activate 'company-set-selection)
   (ad-activate 'company-tooltip--simple-update-offset)
   (ad-activate 'company-tooltip--lines-update-offset)
   (add-to-list 'company-frontends 'company-simple-complete-frontend))

 (provide 'company-simple-complete)
 #+END_SRC

 
* Redirect Back up files into a single file

This saves all of the back-up files in the =.~/.saves=  directory and
keeps your other directories clear from them.

#+BEGIN_SRC emacs-lisp
    (setq backup-directory-alist `(("." . "~/.saves")))
#+END_SRC


* Set Ispell Dictionary

Since emacs 24.4+ ispell.el has built-in support for detecting
Hunspell dictionaries and there is no manual configuration needed.

Just specify the global language that should be used when using the
dictionary.

#+Name: Ispell 
#+BEGIN_SRC emacs-lisp 
    (setq ispell-dictionary "english")
#+END_SRC

Notice that you have both to install ispell and aspell through brew on OSX.


* Snippets

Snippets are a powerful tool that consists of pre-compiled code that
you can enter through some shortcuts. You can either enter and save
your own snippet or you can leverage the already built-in
snippets. These are various and allows you for instance to create
classes, open loops, etc. 

The package for working with snippets is =yasnippet= and the
documentation for the various snippets can be found at

#+BEGIN_SRC emacs-lisp
  (use-package auto-yasnippet

  :ensure t
  :init
  (yas-global-mode 1))
#+END_SRC

** Yasnippet-snippets

   Also download the yasnippet-snippets library. There are many more
   snippets there in comparison to the one included in the auto-yasnippet
   above and I believe it might be useful working with these.

   In his documentation he says that all the snippets will load
   automatically as soon as yasnippet loads. Let's see.

   Nice. This was correct. Once you downlaod the package through MELPA or
   manually setting it into your working directory the snippets will
   automatically be avaiable. No need for configuration in emacs.


* Tramp

  Built in. Read on how to integrate it again.

  To be implemented using: [[https://cestlaz.github.io/posts/using-emacs-25-tramp/][tramp_tut]].

  
** SSH and nice terminal there

The solution to properly ssh into a machine and have a full-fledge
terminal there is to 

- use tramp to ssh into a file. ~C-x C-f~

- you need the user@hostname to do so

- then from there open a second eshell ~C-u 2 M-x eshell~

You will be automatically have your full fledge eshell with set on the
correct directory in the sshed machine.

If you need to connect to a specific port you can use:

- ~C-x C-f /ssh:test@host#2222:/<PATH:file>~

You can inspire yourself following [[https://github.com/jwiegley/emacs-release/blob/master/etc/themes/misterioso-theme.el][this link]].
  


* Javascript

#+begin_src emacs-lisp 
;; to set up javascript properly check at this https://emacs.cafe/emacs/javascript/setup/2017/04/23/emacs-setup-javascript.html

;; to install a node REPL and work with javascript on emacs
(use-package js-comint
 :ensure t)
#+end_src 

To send the commands to the REPL you can use

#+begin_src emacs-lisp 
(add-hook 'js-mode-hook
          (lambda ()
            (local-set-key (kbd "C-<return>") 'js-send-last-sexp)
            (local-set-key (kbd "C-c C-c") 'js-send-buffer)
            (local-set-key (kbd "C-c C-r") 'js-send-region)))
#+end_src 

Good so it is running. You can open a javascript file =file.js=. Then
after starting a REPL via =run-js=, you can send the buffer, region
etc. with the above commands.

** For org babel 

 One command to add the session argument. You have to run this in the
 code chunck.

 #+begin_src emacs-lisp 
(defun ob-js-insert-session-header-arg (session)
  "Insert ob-js `SESSION' header argument.
- `js-comint'
- `skewer-mode'
- `Indium'
"
  (interactive (list (completing-read "ob-js session: "
                                      '("js-comint" "skewer-mode" "indium"))))
  (org-babel-insert-header-arg
   "session"
   (pcase session
     ("js-comint" "\"*Javascript REPL*\"")
     ("skewer-mode" "\"*skewer-repl*\"")
     ("indium" "\"*JS REPL*\""))))

(define-key org-babel-map (kbd "J") 'ob-js-insert-session-header-arg)
 #+end_src 

 #+RESULTS:
 : ob-js-insert-session-header-arg

 Notice that to run the javascript in org chuncks you will pass the
 session with your node REPL.  Check your file on your blog
 =javascript-notes.org=. There it will be clear. Notice that the
 output will not be printed to the org file. Could not find a way
 still to pipe results there correctly. 

 Despite this everything the results will be piped to the REPL and you
 can keep this open and see what happens in there.







* Cpp

  Activate =hs-mode= when opening cpp files to navigate them quickly.

#+begin_src emacs-lisp 
(add-hook 'c-mode-common-hook 'hs-minor-mode)
#+end_src 

#+RESULTS:
| hs-minor-mode | smart-hungry-delete-default-c-mode-common-hook |


* Org Mode

Very nice mode. Important I downloaded 

#+begin_example
    Version: 9.3.6
    Summary: Outline-based notes management and organizer
    Required by: org-gcal-0.2
    Homepage: https://orgmode.org
#+end_example

As the built-in org version was to old for ox-ipynb that exports org
files to =.ipynb=.

#+BEGIN_SRC emacs-lisp
  (require 'org)
#+END_SRC

** Basic configuration

   #+begin_src emacs-lisp 
   ;; ;; To open all .org files in org mode.
   (autoload 'org-mode "org-mode" "Org Mode." t)

   ;; workaround for not workign source code shortcut
   (when (version<= "9.2" (org-version))
     (require 'org-tempo))
   #+end_src

Switch among org buffers. This is a new feature intended to save time
as you will be prompted just with org buffers when changing buffers.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c o") 'org-switchb)

(global-set-key (kbd "C-c M-q") 'fill-paragraph)
#+End_Src

#+Begin_Src emacs-lisp 
(setq org-src-preserve-indentation nil
      org-edit-src-content-indentation 0)
#+end_src 

** Store link to current file

#+begin_src emacs-lisp 
    (global-set-key (kbd "C-c l") 'org-store-link)
#+end_src 

** Export modes

This modes are not found on mac. So far not important as I never
really worked with them. Check at a later point in case of need.

#+BEGIN_SRC emacs-lisp
  ;; ;; Exporting in markdown and beamer mode
  ;; (use-package ox-md
  ;;  :ensure t)
  ;; (use-package ox-beamer
  ;;  :ensure t)
#+END_SRC

** Ob-ipyhton

   To run jupyter like workflow in org mode displaying graphs, using
   multiple languages etc. Notice at the moment I have issue. 

   Package is not on MELPA, but it should. Install it manually. Then you should
   be able to run the below and start to operate through in org-mode
   via ob-ipython.

   I downloaded the package manually in the =.emacs.d= folder. Load it
   adding it to your load path.

   #+BEGIN_SRC emacs-lisp
     ;; Tell emacs where is your personal elisp lib dir
     (add-to-list 'load-path "/Users/marcohassan/.emacs.d/ob-ipython/")
   #+END_SRC


   #+BEGIN_SRC emacs-lisp
     (use-package dash-functional
     :ensure t)

     (use-package s
     :ensure t)     

     (use-package f
     :ensure t)     

     (load "obipython")

      ;;; display/update images in the buffer after I evaluate
     (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
   #+END_SRC

** For Nikola

#+begin_src emacs-lisp 
(defun nikola_img_url()
  (interactive)
  (search-backward "/images")
  (setq p2 (point))
  (search-backward "file")
  (delete-region p2 (point))
  (insert "img-url:")
)
#+end_src 

Enter the last screenshot taken and moved to the =Blog/images= folder.

#+begin_src emacs-lisp 
(defun nikola_enter_last_img()
  (interactive)
  (insert "\n#+begin_export html\n <img src=\"../../images/")
  (insert (shell-command-to-string "cd ~/Desktop/Blog/images/; ls -lt |awk 'FNR == 2 {print $NF}'"))
  (save-excursion
    (insert "\" class=\"center\">\n#+end_export\n")
  )
)
#+end_src 

#+begin_src emacs-lisp 
(defun nikola_img_html()
  (interactive)
  (save-excursion
  (search-backward ".")
  (setq p1 (point))
  (search-backward "/images")
  (kill-region p1(point))
  (setq p2 (point))
  (beginning-of-line)
  (delete-region p2 (point))
  (insert "\n#+begin_export html\n <img src=\"../..")
  (yank)
  (insert ".png\">\n#+end_export\n")
  (kill-line)
  )
  (kill-line)
)
#+end_src 


#+begin_src emacs-lisp 
(eval-after-load 'org' 
  (define-key org-mode-map
    (kbd "C-c M-i") 'nikola_img_url)
  )
#+end_src 

#+begin_src emacs-lisp 
(defun nikola_move_ein_image()
  (interactive)
  (save-excursion
  (setq p1 (point))
  (search-backward "ob-ein")
  (kill-region p1(point))
  (rename-file (concat  "~/Desktop/Blog/bits-of-experience/posts/ein-images/" (substring (car kill-ring) 0 -2)) (concat "~/Desktop/Blog/images/" (substring (car kill-ring) 0 -2)))
  (insert (yank))
  )
)

(defun nikola_ein_to_html()
  (interactive)
  (save-excursion
  (end-of-line)
  (search-backward "ein-images")
  (setq p1 (point))
  (search-forward "ein-")
  (kill-region p1(point))
  (insert "/")
  (end-of-line)
  (call-interactively 'nikola_img_html)
  )
)

(defun nikola_search_next_file()
  (interactive)
  (search-forward "file:")
  (end-of-line)
  (call-interactively 'nikola_move_ein_image)
)
#+end_src 

** Eliminate Results

#+begin_src emacs-lisp 
(defun eliminate-forward-results()
  (interactive)
  (save-excursion
    (search-forward "#+results")
    (org-hide-block-toggle)
    (beginning-of-line)
    (kill-line 2)
  ) 
)

(defun eliminate-backward-results()
  (interactive)
  (save-excursion
    (search-backward "#+results")
    (org-hide-block-toggle)
    (beginning-of-line)
    (kill-line 2)
  )
)
#+end_src 

** Go to the end of the results when particularly long

#+begin_src emacs-lisp 
(defun end-of-results()
  (interactive)
  (search-forward "#+end_example")
)
#+end_src 

** Export .org to .ipynb

   #+BEGIN_SRC emacs-lisp
     ;; Tell emacs where is your personal elisp lib dir
     (add-to-list 'load-path "/Users/marcohassan/.emacs.d/ox-ipynb/")
   #+END_SRC

#+begin_src emacs-lisp 
    (load "ox-ipynb")
    (require 'ox-ipynb)
#+end_src 

  Notice however the *important point*. You have to have your chunks
  in *ipython* and not *ein-python*

** Import .ipynb as .org

To do that please refer to the two step procedure mentioned in [[https://www.reddit.com/r/emacs/comments/7lcgkz/import_a_jupyter_notebook_to_an_orgmode_file/][this
post]].

Start by installing pandoc.

#+begin_example
 brew install pandoc
#+end_example

Essence:

#+begin_example
jupyter nbconvert notebook.ipynb --to markdown
pandoc notebook.md -o notebook.org 
#+end_example


For doing this in a loop you can use the following commands in bash

#+begin_example
$ for file in ./*.ipynb ; do jupyter nbconvert "$file" --to markdown  ; done                                                                      
$ for file in ./*.md ; do pandoc $file -o $(basename -- "$file" .md).org  ; done                                                                    
#+end_example

** Layout

   #+BEGIN_SRC emacs-lisp

     ;; Use syntax highlighting in source blocks while editing.
     (setq org-src-fontify-natively t)

     ;; Make TAB act as if it were issued in a buffer of the languages major mode.
     (setq org-src-tab-acts-natively t)

     ;; I like to see an outline of pretty bullets instead of a list of asterisks.
     (use-package org-bullets
     :ensure t
     :config
     (add-hook 'org-mode-hook 'org-bullets-mode))

     ;; I like seeing a little downward-pointing arrow instead of the usual
     ;; ellipsis (...) that org displays when there is stuff under a header.
     (setq org-ellipsis " >>")
   #+END_SRC

** Grammar Check

   #+BEGIN_SRC emacs-lisp
     ;; Activate flyspell for org documents.
     (use-package flyspell
       :ensure t
       :config
       (add-hook 'org-mode-hook 'flyspell-mode))
   #+END_SRC

** Babel
   
#+begin_src emacs-lisp 
;; For babel evaluing in R
(use-package ess
  :ensure t)

;; For Javascript
(require 'ob-js)
#+end_src 

   #+BEGIN_SRC emacs-lisp
   ;; Allow code evaluation in the org mode source code chunck
   (use-package gnuplot
     :ensure t) ;; recall to download it trough MELPA at first

   (org-babel-do-load-languages
    'org-babel-load-languages
    '((C . t)
      (R . t)
      (sql . t)
      (ein . t)
      (python . t)
      (ipython . t)
      (shell . t)
      (emacs-lisp . t)
      (latex . t)
      (js . t)
      (plantuml . t) ;; for UML diagrams
      ))

   ;; Don't ask before executing code in the chunck.
   (setq org-confirm-babel-evaluate nil)
   #+END_SRC

   #+RESULTS:

Add to company the ob-ipython dict.

#+begin_src emacs-lisp 
   (add-to-list 'company-backends 'company-ob-ipython)
#+end_src 

#+begin_src emacs-lisp 
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
#+end_src 

#+begin_src emacs-lisp 
(setq org-src-preserve-indentation t)
(setq org-src-fontify-natively t)
(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("" "minted"))
(setq org-latex-listings 'minted) 
#+end_src 

** Better navigation Scimax like

#+begin_src emacs-lisp 
 ;; Tell emacs where is your personal elisp lib dir
 (add-to-list 'load-path "/Users/marcohassan/.emacs.d/scimax-ob/")

 (load "scimax-ob")
#+end_src 

Just execute region; not working: [[https://emacs.stackexchange.com/questions/19169/org-mode-execute-region-in-session][here]].

Execute till cursor

#+begin_src emacs-lisp 
(defun babel-till-cursor
  (interactive)
  "
  Split the current src block with point in upper block.
  With a prefix BELOW move point to lower block.
  "
  (let* ((el (org-element-context))
	   (p (point))
	   (language (org-element-property :language el))
	   (switches (org-element-property :switches el))
	   (parameters (org-element-property :parameters el)))

      (insert (format "\n#+END_SRC
                     ,#+BEGIN_SRC %s %s %s\n" language (or switches "") (or parameters ""))))

    (org-babel-previous-src-block)

    (org-babel-execute-src-block)

    (let* ((src (org-element-context))
	   (nlines (org-element-property :post-blank src)))
      (goto-char (org-element-property :end src))

      (when (numberp nlines)
	(forward-line (* -1 (incf nlines))))
      (goto-char (line-end-position)))
    (beginning-of-line)
    (let ((beg (point)))
      (org-babel-next-src-block)
      (forward-line 1)
      (delete-region beg (point))
      (backward-delete-char 1)
      )
)
#+end_src 


#+begin_src emacs-lisp 
(defun babel-after-cursor ()
  "Execute the block up until after the cursor"
  (interactive)
  (let* ((el (org-element-context))
	   (p (point))
	   (language (org-element-property :language el))
	   (switches (org-element-property :switches el))
	   (parameters (org-element-property :parameters el)))

      (insert (format "\n#+END_SRC
                     ,#+BEGIN_SRC %s %s %s\n" language (or switches "") (or parameters "")))

    (org-babel-execute-src-block)
    (delete-region p (point)))
    ;; (previous-line 3)
    ;; (kill-line 3)
)
#+end_src 


For ein issues
#+begin_src emacs-lisp 
;; (defun kill-excess-lines ()
;;   "Execute the block up until after the cursor"
;;   (interactive)
;;     (kill-line 3)
;;     (backward-delete-char 1)
;; )

;; (defun test ()
;;   (interactive)
;;   (call-interactively 'prova-execute-after-cursor)
;;   (sleep-for 1) ;; else part
;;   (call-interactively 'kill-excess-lines) ;; then part
;; )
#+end_src 


#+begin_src emacs-lisp 
(defun babel-cursor-line ()
  (interactive)

  (save-excursion 
     (let* ((el (org-element-context))
	      (p (point))
	      (language (org-element-property :language el))
	      (switches (org-element-property :switches el))
	      (parameters (org-element-property :parameters el))
	      )

     (beginning-of-line)
     (setq beg1 (point))

     (insert (format "\n#+END_SRC
			,#+BEGIN_SRC %s %s %s\n" language (or switches "") (or parameters "")))

     (end-of-line)
     (setq end1 (point))
     (insert (format "\n#+END_SRC
		      ,#+BEGIN_SRC %s %s %s\n" language (or switches "") (or parameters "")))
     )

     (org-babel-previous-src-block)
     (org-babel-execute-src-block)
     (search-backward "#+END_SRC")
     (previous-line 1)
     (kill-line 3)
     (search-forward "#+END_SRC")
     (beginning-of-line)
     (setq p2 (point))
     (search-forward "#+BEGIN_SRC")
     (end-of-line) 
     (delete-region p2 (point))
     (kill-line 2)
   )
)
#+end_src 

#+begin_src emacs-lisp 
(defun babel-eval-region ()
  (interactive)

  (save-excursion

    (let* ((el (org-element-context))
	     (p (point))
	     (language (org-element-property :language el))
	     (switches (org-element-property :switches el))
	     (parameters (org-element-property :parameters el)))

	(insert (format "\n#+END_SRC
		       ,#+BEGIN_SRC %s %s %s\n" language (or switches "") (or parameters "")))

	(exchange-point-and-mark)

	(insert (format "\n#+END_SRC
		       ,#+BEGIN_SRC %s %s %s\n" language (or switches "") (or parameters ""))))

      (org-babel-execute-src-block)

      (previous-line 3)
      (kill-line 3)

      (org-babel-next-src-block)
      (kill-line 1)
      (setq p2 (point))
      (search-backward "#+END_SRC")
      (delete-region p2 (point))
      (kill-line 1)
    )

    (run-with-idle-timer 2 nil
	    (lambda ()
	      (message "%s" (propertize "region executed" 'face '(:foreground "red")))
	      (run-with-idle-timer 3 nil
		      (lambda ()
			(message nil)))))

)
#+end_src 

** Map My Functions OrgMode

Map all the nice execution functions for org babel chuncks.

#+begin_src emacs-lisp 
(eval-after-load 'org' (progn 
			 (define-key org-mode-map
			   (kbd "C-c s-c") 'scimax-execute-and-next-block)
			 (define-key org-mode-map
			   (kbd "C-c C-v s-a") 'scimax-insert-src-block)
			 (define-key org-mode-map
			   (kbd "C-c s-m") 'scimax-ob-merge-blocks)
			 (define-key org-mode-map
			   (kbd "C-c s-k") 'scimax-ob-kill-block-and-results)
			 (define-key org-mode-map
			   (kbd "C-c s-l") 'scimax-ob-clear-all-results)
			 (define-key org-mode-map
			   (kbd "C-c C-v m") 'scimax-ob-jump-to-end)
			 (define-key org-mode-map
			   (kbd "C-c s-h") 'babel-till-cursor)
			 (define-key org-mode-map
			   (kbd "C-c s-a") 'babel-after-cursor)
			 (define-key org-mode-map
			   (kbd "C-c s-p") 'babel-cursor-line)
			 (define-key org-mode-map
			   (kbd "C-c s-r") 'babel-eval-region)
			 (define-key org-mode-map
			   (kbd "C-c s-f") 'eliminate-forward-results)
			 (define-key org-mode-map
			   (kbd "C-c s-b") 'eliminate-backward-results)
			 (define-key org-mode-map
			   (kbd "C-c s-e") 'end-of-results)
			 ))
#+end_src 

** PlantUML

   For creating UML diagrams in org mode. Followed the instructions
   [[http://eschulte.github.io/babel-dev/DONE-integrate-plantuml-support.html][here]] for the set-up. You can download the necessary =.jar= file
   [[https://sourceforge.net/projects/plantuml/files/plantuml.jar/download][here]]. I moved it in the =.emacs.d= repo.

   Important is moreover to install =graphviz= if you want to create
   diagrams that are not sequence diagrams. This can be done in the
   MAC [[https://brewinstall.org/install-graphviz-on-mac-with-brew/][as follows]].

   #+begin_src emacs-lisp 
   (setq org-plantuml-jar-path
	 (expand-file-name "~/.emacs.d/plantuml.jar"))
   #+end_src 

** Org-Blocks Display temporarily line numbers

From Kitchin [[http://kitchingroup.cheme.cmu.edu/blog/2015/10/13/Line-numbers-in-org-mode-code-blocks/][link]].

#+begin_src emacs-lisp 
(defun temp-line-src-block ()
  (interactive)
      (defvar number-line-overlays '()
	"List of overlays for line numbers.")

      (make-variable-buffer-local 'number-line-overlays)

      (defun number-line-src-block ()
	(save-excursion
	  (let* ((src-block (org-element-context))
		 (nlines (- (length
			     (s-split
			      "\n"
			      (org-element-property :value src-block)))
			    1)))
	    (goto-char (org-element-property :begin src-block))
	    (re-search-forward (regexp-quote (org-element-property :value src-block)))
	    (goto-char (match-beginning 0))

	    (loop for i from 1 to nlines
		  do
		  (beginning-of-line)
		  (let (ov)
		    (setq ov (make-overlay (point) (point)))
		    (overlay-put ov 'before-string (format "%3s " (number-to-string i)))
		    (add-to-list 'number-line-overlays ov))
		  (next-line))))

	;; now read a char to clear them
	(read-key "Press a key to clear numbers.")
	(mapc 'delete-overlay number-line-overlays)
	(setq number-line-overlays '()))

      (number-line-src-block)
)
#+end_src 

Bind it to a kbd

#+begin_src emacs-lisp 
;; define keyboard shortcuts for special mode
(eval-after-load "org-mode"
     (define-key org-mode-map (kbd "C-c C-v 1") 'temp-line-src-block)
)
#+end_src 

** Agenda

*** General Configuration

   #+BEGIN_SRC emacs-lisp
     ;; Shortcut for org agenda
     (define-key global-map "\C-ca" 'org-agenda)


     ;; specify to-do iterations with C-c t
     (setq org-todo-keywords
	   '((sequence "TODO" "IN-PROGRESS" "WAITING" "ISSUE" "FIXED" "DONE")))
  #+END_SRC

*** Open agenda into its own buffer

 #+BEGIN_SRC emacs-lisp
 (defun air-pop-to-org-agenda (split)
   "Visit the org agenda, in the current window or a SPLIT."
   (interactive "P")
   (org-agenda-list)
   (when (not split)
     (delete-other-windows)))

 (define-key global-map (kbd "C-c t a") 'air-pop-to-org-agenda)
 ;; advanced syntax. with C-u C-c t a you open the agenda in the other
 ;; window without deleting it.
 #+END_SRC

*** Task Manager and Org Agenda

    Org mode has the customizable variable org-agenda-files. The files
    listed by absolute path under this variable are used for building
    the org agenda window. If an element in the list is a directory,
    then all .org files matching the org-agenda-regex are processed to
    build the agenda view.

    #+BEGIN_SRC emacs-lisp
    ;; Create and Specify Agenda folder.
    (setq org-agenda-files (list "~/Dropbox/Applicazioni/MobileOrg/capture.org"
				 "~/Dropbox/Applicazioni/MobileOrg/mobileorg.org"
				 "~/Dropbox/Applicazioni/MobileOrg/inbox.org"
				 "~/Dropbox/Applicazioni/MobileOrg/todos.org"))
    #+END_SRC
    
    #+BEGIN_SRC emacs-lisp
    ;;(setq org-directory "~/Dropbox/Applicazioni/MobileOrg/")
    ;;(setq org-mobile-inbox-for-pull "~/Desktop/org/inbox.org")

    (setq org-mobile-directory "~/Dropbox/Applicazioni/MobileOrg/") 
    #+END_SRC

    Notice that to pull the agendas entries from the mobile; you have to
    save them in the =mobileorg.org= file in the
    =Dropbox/Applicazioni/Mobileorg= folder. Just then you will be able to
    pull the agenda into the ~org-mobile-inbox-for-pull~ above. 

    The checksum are a nice way to speed up synchronization in the
    sense that just things that where not changed will be
    synchronized. The checksum is the way to see whether the documents
    were synchronized or not.


    #+begin_src emacs-lisp 
    ;; (defcustom org-mobile-checksum-binary "/usr/bin/shasum"
    ;;    "Executable used for computing checksums of agenda files."
    ;;    :group 'org-mobile
    ;;    :type 'string)
    #+end_src 

*** Todo current buffer

Open org agenda restrict it and open to do.

#+begin_src emacs-lisp 
;; (defun org-todo-list-current-file (&optional arg)
;;   "Like `org-todo-list', but using only the current buffer's file."
;;   (interactive "P")
;;   (let ((org-agenda-files (list (buffer-file-name (current-buffer)))))
;;     (if (null (car org-agenda-files))
;;         (error "%s is not visiting a file" (buffer-name (current-buffer)))
;;       (org-todo-list arg))))
#+end_src 

#+BEGIN_SRC emacs-lisp
;; (add-hook 'org-mode-hook
;; 	    (local-set-key (kbd "C-c C-v -")
;; 			   'org-todo-list-current-file)
;; 	    )
#+END_SRC

*** Archiving

    #+BEGIN_SRC emacs-lisp
      ;; Set archiving location.
      (setq org-archive-location "~/Desktop/Archive/archive.org::* From %s")

      ;; Done and archive
      (defun mark-done-and-archive ()
	"Mark the state of an org-mode item as DONE and archive it."
	(interactive)
	(org-todo 'done)
	(org-archive-subtree))

      (define-key org-mode-map (kbd "C-c C-x C-s") 'mark-done-and-archive)

      ;; Record the time that a todo was archived.
      (setq org-log-done 'time)
    #+END_SRC

*** Capture
   
    This section frames the way in which to capture short notes and to
    do stuff in the middle of the day. Here everyday tasks will be
    saved.

 #+begin_src emacs-lisp 
 ;; where the notes will be stored. the reference is the previously
 ;; defined org directory.
  (setq org-default-notes-file "~/Dropbox/Applicazioni/MobileOrg/capture.org")
 #+end_src 

 Define the global map for using org-capture

 #+begin_src emacs-lisp 
 (global-set-key  (kbd "\C-c c")  'org-capture)
 #+end_src 

 This is the templates that will allow you to quickly add notes to your
 capture.org file.

 #+begin_src emacs-lisp 
 (setq org-capture-templates
      (quote (("t" "todo" entry (file "~/Dropbox/Applicazioni/MobileOrg/capture.org")
	     "* TODO %?\n%U\n%a\n") ;; if you want to clock in time --- :clock-in t :clock-resume t)
	      ("n" "note" entry (file "~/Dropbox/Applicazioni/MobileOrg/capture.org")
	     "* %? :NOTE:\n%U\n%a\n") ;; if you want to clock in time --- :clock-in t :clock-resume t)
	    )))
 #+end_src 

*** Sychronization with Google Calendar

You have to mask this one if you want to push on GitHub. 

Here you mask your settings through a json
#+begin_src emacs-lisp 
(require 'json)

(setq credID (let* ((json-object-type 'hash-table)
		      (json-array-type 'list)
		      (json-key-type 'string)
		      (json (json-read-file "/Users/marcohassan/Desktop/emacs_config/Emacs Configuration/credentials/gCred.json")))
		  (gethash "client-id" json)))

(setq secret (let* ((json-object-type 'hash-table)
		      (json-array-type 'list)
		      (json-key-type 'string)
		      (json (json-read-file "/Users/marcohassan/Desktop/emacs_config/Emacs Configuration/credentials/gCred.json")))
		  (gethash "secret" json)))
#+end_src 

#+begin_src emacs-lisp 
(setq package-check-signature nil)

(use-package org-gcal
  :ensure t
  :config
  (setq org-gcal-client-id credID 
	org-gcal-client-secret secret
	org-gcal-file-alist) '(("marco.hassan30@gmail.com" .  "~/dropbox/Applicazioni/MobileOrg/mobileorg.org")));
#+end_src 

#+RESULTS:
: t

#+begin_src emacs-lisp 
(add-hook 'org-agenda-mode-hook (lambda () (org-gcal-sync) ))
(add-hook 'org-capture-after-finalize-hook (lambda () (org-gcal-sync) ))
#+end_src 

#+RESULTS:
| lambda | nil | (org-gcal-sync) |

*** Description of org-agenda properties

    [[https://orgmode.org/manual/Repeated-tasks.html][This]] is a nice article that explains you well how to use the
    agenda tags.

    Basically there are three types of hourly tags:

    - =+= it means that when you mark it as done it shifts by the
      given amount of time.

    - =++= it means that when you mark it as done it shifts by the
      given amount of time *in the future*. It means that for instance
      if you had a scheduled event that you do not mark as done since
      3 weeks it will not mark it as done and shift the date 2 weeks
      in the past but rather 1 week *into the future*.

    - =.+= it means that when you mark it as done it shifts by the
      given amount as of *today/exact moment when you mark it as done*.

*** Org super agenda   

    It's a way to make the agenda look much nicer. Have to look at it
    at some point.

*** Calfw


#+begin_src emacs-lisp 
(use-package calfw)

(use-package calfw-org
  :after calfw
  )
#+end_src 

** Org tangle append

Should tangle then the chunck at the end of a file.
#+begin_src emacs-lisp 
(defun org-babel-tangle-append ()
  "Append source code block at point to its tangle file.
The command works like `org-babel-tangle' with prefix arg
but `delete-file' is ignored."
  (interactive)
  (cl-letf (((symbol-function 'delete-file) #'ignore))
    (org-babel-tangle '(4))))

(defun org-babel-tangle-append-setup ()
  "Add key-binding C-c C-v C-t for `org-babel-tangle-append'."
  (org-defkey org-mode-map (kbd "C-c C-v +") 'org-babel-tangle-append))

(add-hook 'org-mode-hook #'org-babel-tangle-append-setup)
#+end_src 

** Org results toggle hide shortcut

#+begin_src emacs-lisp 
(org-defkey org-mode-map (kbd "C-c C-x r") 'org-babel-hide-result-toggle)
#+end_src 

#+RESULTS:
: org-babel-hide-result-toggle

** Enter last image

#+begin_src emacs-lisp 
(defun screenshots_enter_last_img()
  (interactive)
  (insert "[[file:~/Desktop/Screenshots/")
  (insert (shell-command-to-string "cd ~/Desktop/Screenshots/; ls -lt | awk 'FNR == 2 {a=match($0, $9); print substr($0,a)}'"))
  )
#+end_src 

#+RESULTS:
: screenshots_enter_last_img

** IN-PROGRESS This might be big - TEST

It works well... have simply to write a function to set the
org-destination location one time off... And then have to adjust the
properties... not archive_file but rather copy file... however very
nice... with this I will have a great workflow.

#+begin_src emacs-lisp 
(setq org-destination-location "~/Desktop/test.org::* From %s")
#+end_src 

Have also the issue that at each archivation you do not cancel the
previously archived section.

But good.. Generally a solid starting point. 

Then you can sort via =org-sort-entries= on time in reverse and kill
all of the younger headers with the same title. And then order again
based on archiving age.

Notice that you should move the properties one header up.

#+begin_src emacs-lisp 
(defun org-subtree-to-file (&optional find-done)
  "Move the current subtree to the archive.
The archive can be a certain top-level heading in the current
file, or in a different file.  The tree will be moved to that
location, the subtree heading be marked DONE, and the current
time will be added.

When called with a single prefix argument FIND-DONE, find whole
trees without any open TODO items and archive them (after getting
confirmation from the user).  When called with a double prefix
argument, find whole trees with timestamps before today and
archive them (after getting confirmation from the user).  If the
cursor is not at a headline when these commands are called, try
all level 1 trees.  If the cursor is on a headline, only try the
direct children of this heading."
  (interactive "P")
  (if (and (org-region-active-p) org-loop-over-headlines-in-active-region)
      (let ((cl (if (eq org-loop-over-headlines-in-active-region 'start-level)
		    'region-start-level 'region))
	    org-loop-over-headlines-in-active-region)
	(org-map-entries
	 `(progn (setq org-map-continue-from (progn (org-back-to-heading) (point)))
		 (org-archive-subtree ,find-done))
	 org-loop-over-headlines-in-active-region
	 cl (if (org-invisible-p) (org-end-of-subtree nil t))))
    (cond
     ((equal find-done '(4))  (org-archive-all-done))
     ((equal find-done '(16)) (org-archive-all-old))
     (t
      ;; Save all relevant TODO keyword-related variables.
      (let* ((tr-org-todo-keywords-1 org-todo-keywords-1)
	     (tr-org-todo-kwd-alist org-todo-kwd-alist)
	     (tr-org-done-keywords org-done-keywords)
	     (tr-org-todo-regexp org-todo-regexp)
	     (tr-org-todo-line-regexp org-todo-line-regexp)
	     (tr-org-odd-levels-only org-odd-levels-only)
	     (this-buffer (current-buffer))
	     (time (format-time-string
		    (substring (cdr org-time-stamp-formats) 1 -1)))
	     (file (abbreviate-file-name
		    (or (buffer-file-name (buffer-base-buffer))
			(error "No file associated to buffer"))))
	     (location (org-archive--compute-location
			(or (org-entry-get nil "TANGLE" 'inherit)
			    org-destination-location))) ;; simply replaced org-archive-location witth org-destination-location
	     (afile (car location))
	     (heading (cdr location))
	     (infile-p (equal file (abbreviate-file-name (or afile ""))))
	     (newfile-p (and (org-string-nw-p afile)
			     (not (file-exists-p afile))))
	     (buffer (cond ((not (org-string-nw-p afile)) this-buffer)
			   ((find-buffer-visiting afile))
			   ((find-file-noselect afile))
			   (t (error "Cannot access file \"%s\"" afile))))
	     level datetree-date datetree-subheading-p)
	(when (string-match "\\`datetree/" heading)
	  ;; Replace with ***, to represent the 3 levels of headings the
	  ;; datetree has.
	  (setq heading (replace-regexp-in-string "\\`datetree/" "***" heading))
	  (setq datetree-subheading-p (> (length heading) 3))
	  (setq datetree-date (org-date-to-gregorian
			       (or (org-entry-get nil "CLOSED" t) time))))
	(if (and (> (length heading) 0)
		 (string-match "^\\*+" heading))
	    (setq level (match-end 0))
	  (setq heading nil level 0))
	(save-excursion
	  (org-back-to-heading t)
	  ;; Get context information that will be lost by moving the
	  ;; tree.  See `org-archive-save-context-info'.
	  (let* ((all-tags (org-get-tags))
		 (local-tags
		  (cl-remove-if (lambda (tag)
				  (get-text-property 0 'inherited tag))
				all-tags))
		 (inherited-tags
		  (cl-remove-if-not (lambda (tag)
				      (get-text-property 0 'inherited tag))
				    all-tags))
		 (context
		  `((category . ,(org-get-category nil 'force-refresh))
		    (file . ,file)
		    (itags . ,(mapconcat #'identity inherited-tags " "))
		    (ltags . ,(mapconcat #'identity local-tags " "))
		    (olpath . ,(mapconcat #'identity
					  (org-get-outline-path)
					  "/"))
		    (time . ,(concat (concat "<" time) ">"))
		    (todo . ,(org-entry-get (point) "TODO")))))
	    ;; We first only copy, in case something goes wrong
	    ;; we need to protect `this-command', to avoid kill-region sets it,
	    ;; which would lead to duplication of subtrees
	    (let (this-command) (org-copy-subtree 1 nil t))
	    (set-buffer buffer)
	    ;; Enforce Org mode for the archive buffer
	    (if (not (derived-mode-p 'org-mode))
		;; Force the mode for future visits.
		(let ((org-insert-mode-line-in-empty-file t)
		      (org-inhibit-startup t))
		  (call-interactively 'org-mode)))
	    (when (and newfile-p org-archive-file-header-format)
	      (goto-char (point-max))
	      (insert (format org-archive-file-header-format
			      (buffer-file-name this-buffer))))
	    (when datetree-date
	      (require 'org-datetree)
	      (org-datetree-find-date-create datetree-date)
	      (org-narrow-to-subtree))
	    ;; Force the TODO keywords of the original buffer
	    (let ((org-todo-line-regexp tr-org-todo-line-regexp)
		  (org-todo-keywords-1 tr-org-todo-keywords-1)
		  (org-todo-kwd-alist tr-org-todo-kwd-alist)
		  (org-done-keywords tr-org-done-keywords)
		  (org-todo-regexp tr-org-todo-regexp)
		  (org-todo-line-regexp tr-org-todo-line-regexp)
		  (org-odd-levels-only
		   (if (local-variable-p 'org-odd-levels-only (current-buffer))
		       org-odd-levels-only
		     tr-org-odd-levels-only)))
	      (goto-char (point-min))
	      (org-show-all '(headings blocks))
	      (if (and heading (not (and datetree-date (not datetree-subheading-p))))
		  (progn
		    (if (re-search-forward
			 (concat "^" (regexp-quote heading)
				 "\\([ \t]+:\\(" org-tag-re ":\\)+\\)?[ \t]*$")
			 nil t)
			(goto-char (match-end 0))
		      ;; Heading not found, just insert it at the end
		      (goto-char (point-max))
		      (or (bolp) (insert "\n"))
		      ;; datetrees don't need too much spacing
		      (insert (if datetree-date "" "\n") heading "\n")
		      (end-of-line 0))
		    ;; Make the subtree visible
		    (outline-show-subtree)
		    (if org-archive-reversed-order
			(progn
			  (org-back-to-heading t)
			  (outline-next-heading))
		      (org-end-of-subtree t))
		    (skip-chars-backward " \t\r\n")
		    (and (looking-at "[ \t\r\n]*")
			 ;; datetree archives don't need so much spacing.
			 (replace-match (if datetree-date "\n" "\n\n"))))
		;; No specific heading, just go to end of file, or to the
		;; beginning, depending on `org-archive-reversed-order'.
		(if org-archive-reversed-order
		    (progn
		      (goto-char (point-min))
		      (unless (org-at-heading-p) (outline-next-heading)))
		  (goto-char (point-max))
		  ;; Subtree narrowing can let the buffer end on
		  ;; a headline.  `org-paste-subtree' then deletes it.
		  ;; To prevent this, make sure visible part of buffer
		  ;; always terminates on a new line, while limiting
		  ;; number of blank lines in a date tree.
		  (unless (and datetree-date (bolp)) (insert "\n"))))
	      ;; Paste
	      (org-paste-subtree (org-get-valid-level level (and heading 1)))
	      ;; Shall we append inherited tags?
	      (and inherited-tags
		   (or (and (eq org-archive-subtree-add-inherited-tags 'infile)
			    infile-p)
		       (eq org-archive-subtree-add-inherited-tags t))
		   (org-set-tags all-tags))

	      ;; Add the context info.
	      (dolist (item org-archive-save-context-info)
		(let ((value (cdr (assq item context))))
		  (when (org-string-nw-p value)
		    (org-entry-put
		     (point)
		     (concat "TANGLE_" (upcase (symbol-name item)))
		     value))))
	      (widen))))
	;; Here we are back in the original buffer.  Everything seems
	;; to have worked.  So now run hooks, cut the tree and finish
	;; up.
	(run-hooks 'org-archive-hook)
	(let (this-command) (org-cut-subtree))
	(when (featurep 'org-inlinetask)
	  (org-inlinetask-remove-END-maybe))
	(setq org-markers-to-move nil)
	(when org-provide-todo-statistics
	  (save-excursion
	    ;; Go to parent, even if no children exist.
	    (org-up-heading-safe)
	    ;; Update cookie of parent.
	    (org-update-statistics-cookies nil)))
	(message "Subtree archived %s"
		 (if (eq this-buffer buffer)
		     (concat "under heading: " heading)
		   (concat "in file: " (abbreviate-file-name afile)))))))
    (org-reveal)
    (if (looking-at "^[ \t]*$")
	(outline-next-visible-heading 1))))
#+end_src 



* Time management and Pomodoro Technique
  :LOGBOOK:
  CLOCK: [2021-02-05 Fri 12:02]--[2021-02-05 Fri 12:15] =>  0:13
  CLOCK: [2021-02-05 Fri 11:48]--[2021-02-05 Fri 12:01] =>  0:13
  CLOCK: [2021-02-05 Fri 11:43]--[2021-02-05 Fri 11:48] =>  0:05
  CLOCK: [2021-02-05 Fri 11:39]--[2021-02-05 Fri 11:42] =>  0:03
  CLOCK: [2021-02-05 Fri 11:39]--[2021-02-05 Fri 11:39] =>  0:00
  :END:

  This section experiments a bit with some time management
  techniques. I discovered it is not just bla bla. You can in fact
  work much more productively with basics time management
  techniques. I started using some during my last exam session. It was
  a hard one and I was often distracted. Well I decided to set
  timers. During some time I was working. Then I was regularly doing
  breaks reading my current book. It worked and I managed to read 250
  pages during the most hard exam session I ever experienced. 

  It turned out when discussing with my dare gf, that there is a very
  well known technique that supports such a behaviour. It is the
  pomodoro technique. It consists in measuring everything in
  pomodoros. That is 25min. intervals.

  During such intervals you work at 100% without any distractions and
  then from time to time you take breaks and switch off. But when you
  work you work at 100%. You do not mix stuff.

  Let's start with the basics in emacs. And let's then expand to the
  pomodoro.

  
** Org-Clocks

   So the basics thing is to log all of your work. I.e. check how much
   time you needed to compute tasks. After all: /just if you can
   measure it, you can improve it/. 

   One very easy way to do that in emacs is via the =org-clock-in=
   function mapped to ~C-c C-x TAB~, in my emacs. Its correspondent is
   =org-clock-out= mapped to ~C-c C-x C-o~. In such a way you will be
   able to start a measurement in the org header and stop it and the
   time the time of the clock will be registered in the logbook. Check
   this very emacs file you are editing should you be confused at any
   time. Also interesting are the ~C-c C-x C-j~, i.e. the
   =org-clock-goto= command that makes you jump to the header where
   your clocks are registered. Even more interesting are the ~C-c C-x
   C-d~ command, i.e. =org-clock-display= command that when run in the
   section it tells you exactly how many hours you spend on the section
   according to your clocked in time.

   Well, that all came in by default with emacs =org-mode=. I just have
   never the time so far to check at it properly and makes sense of all
   of that. Now that I am taking the time and writing this post it
   makes well sense. Wonderful tool. Quick usage through the
   shortcuts. 

   Notice that there are also other more advanced features. Let's
   leave it for now. Should you want to check at them later check the
   official [[https://orgmode.org/manual/Clocking-Work-Time.html][org documentation]].

** Pomodoro

   Let's go back to the pomodoro technique, the thing for which you
   actually started to dig into such time management tools. So
   apparently tools to work with the pomodoro technique were
   implemented /en mass/ into emacs. Well no surprise. If you know
   emacs, then you know we emacs people value a lot productivity and
   try all the sorts of the escamotages in order to increase it.

   So the most popular package is the pomodoro one. You can install it
   as follows given that you are using the =use-package= package. 

 #+begin_src emacs-lisp 
;; could not find it normally.
;; (use-package pomodoro
;;   :ensure t
;;   :init (pomodoro-add-to-mode-line))


;; use the quelpa mirror because of that
 (use-package pomodoro
   :quelpa (pomodoro :fetcher github :repo "emacsmirror/pomodoro")
   :config (pomodoro-add-to-mode-line)
   :bind (("C-c C-v s-p" . pomodoro-start)
	  ("C-c C-v s-s" . pomodoro-stop)
          ("C-c C-x s-p" . pomodoro-pause)
	  ("C-c C-x s-r" . pomodoro-resume))
   )
 #+end_src 


   Good with the above quelpa mirror you managed to install it. Notice
   that here the functions to start your pomodoro timer is
   =pomodoro-start=. There are then a couple of functions to =pause=,
   =resume= etc. your pomodoro. Notice that here the time with the
   add-to-mode-line above is displayed in little on the bottom left of
   your mode-line. That is fine. Use this in general and not when
   editing org files. For this there is a better option that we will
   explore next.

   Another option that directly integrates with emacs org
   mode clocks previously described is the =org-pomodoro=
   package. That starts a clock as the =clock-in= command above and
   after 25 min. it should expire. I read that the notification when
   it expires is not that great so they suggested to add the
   =libnotify= option below.

 #+begin_src emacs-lisp 
(use-package org-pomodoro
  :ensure t
  :config
  (setq alert-user-configuration (quote ((((:category . "org-pomodoro")) libnotify nil))))
   :bind (("C-c C-x s-o" . org-pomodoro)
	  ("C-c C-x s-e" . org-pomodoro-extend-last-clock))
)
 #+End_src 

   Let's give it a go for the next task then. Now I have no time to
   wait other 25min. to see the behaviour. The milestone was set and
   for the next projects you can start with your time management
   techniques.


* EIN

#+begin_src emacs-lisp 
(define-key python-mode-map (kbd "C-c s-c") 'ein:edit-cell-save-and-execute)
#+end_src 

Consider [[https://github.com/nnicandro/emacs-jupyter][this package]]. Looks promising.


* Nikola

Necessary for posting in org mode. Otherwise you will get bugs when publishing.

#+begin_src emacs-lisp 
  (use-package htmlize
    :ensure t)
#+end_src 


* Magit

#+begin_src emacs-lisp 
(use-package magit
  :ensure t) ;; recall to download it trough MELPA at first
#+end_src 

Enable magit interface on global mode.

#+begin_src emacs-lisp 
(global-set-key (kbd "C-x g") 'magit-status)
#+end_src 


* Latex

#+begin_src emacs-lisp 
(setq exec-path (append exec-path '("/usr/texbin")))
#+end_src 

#+begin_src emacs-lisp 
(add-to-list 'org-latex-packages-alist '("" "listingsutf8"))
(add-to-list 'org-latex-packages-alist '("" "minted"))
#+end_src 

You have to have xelatex on your $PATH for that.

Good - notice that this first chunck works well when you want to allow
minted content in your files. 

#+begin_src emacs-lisp 
   ;; Allowing minted to highlight code in latex mode when exporting
   
   (setq org-latex-pdf-process
	 '("xelatex -8bit -shell-escape  -interaction nonstopmode -output-directory %o %f"
            "bibtex %b"
	   "xelatex -8bit -shell-escape  -interaction nonstopmode -output-directory %o %f"
	   "xelatex -8bit -shell-escape  -interaction nonstopmode -output-directory %o %f"))


   (setq org-latex-listings 'minted)
   (setq org-latex-minted-options
	 '(("frame" "lines") ("linenos=true")))
#+end_src 

#+RESULTS:
| frame        | lines |
| linenos=true |       |

#+begin_src emacs-lisp 
;; For working with org-ref and having correct export.
;; (setq org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))
#+end_src 

Then compile the latex with =C-c C-c= command.

** Citation in Org-mode
 
   Note that since a bit in newer versions of org-mode you do not have
   anymore contributed packages. I needed ox-bibtex in there. I also
   could not find it in /epkgs/. So I downloaded it manually and moved
   the =contrib= folder of older org-mode versions to the =.emacs.d= folder.

#+begin_src emacs-lisp 
;; to add ox-bibtex add the path
(add-to-list 'load-path "/Users/marcohassan/.emacs.d/org_mode_contrib/lisp/")
(require 'ox-bibtex)
(require 'org-bibtex)
(require 'bibtex-completion) ;; had also to install this manually
#+end_src 

#+RESULTS:
: bibtex-completion

There is some issue with helm-bibtex, this was a dependency of
org-ref. I uninstalled both and now I solved the issue. A new bibtex
version was installed that seems to integrate correctly now.

Needed as well =bibtex2html=. Can be installed with brew.

#+begin_src emacs-lisp 
;; use the quelpa mirror because of that
 (use-package org-ref
   :ensure t
   :quelpa (org-ref :fetcher github :repo "emacsmirror/org-ref")
   :bind (
          ("C-x s-c" . org-ref-helm-insert-cite-link)
          ("C-x s-o" . org-ref-open-url-at-point)
         )
)
#+end_src 

#+RESULTS:
: org-ref-open-url-at-point


#+begin_src emacs-lisp 
(setq reftex-default-bibliography '("/Users/marcohassan/Desktop/Bayesian_Net_Thesis/literature/references.bib"))

;; see org-ref for use of these variables
(setq  org-ref-bibliography-notes "~/Desktop/Bayesian_Net_Thesis/literature/notes.org"
       org-ref-default-bibliography '("~/Desktop/Bayesian_Net_Thesis/literature/references.bib")
       org-ref-pdf-directory "~/Desktop/Thesis/Bayesian_Net_Thesis/bibtex-pdfs/")
#+end_src 

#+RESULTS:
: ~/Desktop/Thesis/Bayesian_Net_Thesis/bibtex-pdfs/

In general it is working like a charm. I just have to change some
bindings. Find the functionalities of it [[https://www.youtube.com/watch?v=2t925KRBbFc][here]]. 

I love =org-ref= it is an outstanding package. Note that for some
reason every time I open a file after reopening emacs the file does
not check the link with the bibliography. I have to manually call
the =org-ref-insert-bibliography-link=. This is annoying. Try to solve
this issue at some point. Also some functions are missing. Such as
this very labels tags. After calling a function such as
=org-ref-insert-ref-link= they appear. Weird behaviour. Something is
for sure broken. A pity that this library is not well maintained. It
is a bomb but it refers and leverage old libraries. [[label:issue_link_at_startup]]

Note that at this stage I am was not able to download the papers
directly. I will fix it at some point later if I manage. [[label:issue_pdf_downlaod]]


* Projectile

  This can be used to search within a project in all files etc.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t)
  ;; Later on, after loading exec-path-from-shell package

  (projectile-mode +1)
  (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
  (setq projectile-require-project-root nil)
#+END_SRC

#+RESULTS:

#+begin_src emacs-lisp 
 (global-set-key (kbd "C-x s-r") 'projectile-next-project-buffer)
 (global-set-key (kbd "C-x s-l") 'projectile-previous-project-buffer)
#+end_src 

#+RESULTS:
: projectile-previous-project-buffer

  Install =ag= to search with it in projectile

#+begin_src emacs-lisp 
(use-package ag
  :ensure t)
#+end_src 

#+RESULTS:

** Org Projectile

Adds the possibility to edit org todos files via capture in a default
org file storing todos for the specific project. Essentially the same
as org capture at projectile level.

In order to use it you have first to create the =tasks.org= file in
the correct location and finally to use the =C-c n p= shortcut below.

#+begin_src emacs-lisp 
(use-package org-projectile
  :bind (("C-c n p" . org-projectile-project-todo-completing-read)
         ("C-c n c" . org-projectile-capture-for-current-project))
  :config
  (progn
    (setq org-projectile-projects-file
          "tasks.org")
    (setq org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
    (push (org-projectile-project-todo-entry) org-capture-templates))
  :ensure t)
#+end_src 

#+RESULTS:
: org-projectile-capture-for-current-project


* Typescript

For syntax highlighting in typescript. I do not use it myself so
syntax highlighting is sufficient. If you will ever have to write it
there are advanced packages providing more support such as _tide_.

#+begin_src emacs-lisp 
(use-package typescript-mode
  :ensure t) ;; recall to download it trough MELPA at first
#+end_src 


* Python

Set path to python executable so that emacs can leverage it. This
step is necessary when operating through Windows OS.

#+BEGIN_SRC emacs-lisp
    (use-package elpy
      :ensure t
      :config
      (put 'set-goal-column 'disabled nil)
      (elpy-enable)
      (setq elpy-rpc-ignored-buffer-size (* 1024 1024 1024))
      (setq python-indent-offset 4)

      ;; interactive python
      (setq python-shell-interpreter "python3" ;; "ipython"
	    elpy-rpc-python-command "python3"  ;; "ipython"
	    python-shell-interpreter-args "-i"));; "-i --simple-promt"

    ;; notice that ipython functions just with orgbabel combination on the
    ;; mac. there are currently soume issues to be solved. this causes
    ;; isssues when editing with C-c ' on mac. 

    (when (require 'flycheck  nil t)
      (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
      (add-hook 'elpy-mode-hook 'flycheck-mode))


    ;; (use-package elpy
    ;;   :ensure t)
    ;; (elpy-enable) ;; initialize elpy for python IDE in emacs

    ;; ;; Activate flycheck instead of flymake from eply package
    ;; (when (require 'flycheck  nil t)
    ;;   (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
    ;;   (add-hook 'elpy-mode-hook 'flycheck-mode))

    ;; ;; Activate autopep. This integrates with Emacs so that when you save a
    ;; ;; file trough the -C-x C-s- cmd it will automatically format and correct
    ;; ;; any PEP8 errors (excluding the ones that you may specify)

    ;; Did not especially appreciated autopep8. Leave it out.
    (use-package py-autopep8
      :ensure t)
    (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)

    ;; ;; Integrate the eply mode with the IPython REPL and the Jupyter Notebooks.
    ;; ;; This will allow to run Jupyter Notebooks that looks  very much like
    ;; ;; R .rmd files directly on Emacs !after connecting to the notebook online!

    ;; (setq python-shell-interpreter "ipython" 
    ;; 	python-shell-interpreter-args "-i --simple-prompt");; uses ipython interpreter. Please remember on Windows systems that you have to download python on winodws and install ipython through the automatically downloaded pip. Then add to the path the folder including ipython and you are good to go.

    ;; ;; Set standard python interpreter as python 3
    ;; (setq elpy-rpc-python-command "ipython")

    ;; Set up virtual environments emacs connection
    (use-package virtualenvwrapper
      :ensure t)
    (venv-initialize-interactive-shells) ;; if you want interactive shell support
    (venv-initialize-eshell) ;; if you want eshell support
    ;; note that setting `venv-location` is not necessary if you
    ;; use the default location (`~/.virtualenvs`), or if the
    ;; the environment variable `WORKON_HOME` points to the right place
    (setq venv-location "/Users/marcohassan/Desktop/python_venv")

    ;; Add hook for cÃ²mment highlighting.
    ;;(add-hook 'python-mode-hook 'add-custom-keyw)
#+END_SRC

Good. After installing ipyhton thorugh pip everything is working
smoothly. Remember to run pip on DOS and not on emacs shell as at the
moment emacs shell is set to be the shell interacting with the Linux
partition.

** Running Code in different python runtimes

It happened to me that I had to run an algorithm that was
experimental and was taking a lot of time to run. For this I did could
not wait until each of the experiment was finished before starting a
new one. 

I had to start new processes concurrently. 

Moreover this is a good trivial way to parallelize in your algorithm
in case you can simply do it letting it run on different subsets of
data as was the case for me with the spade algorithm.

In order to do that you can leverage the =python-shell-xxx=  commands.

Notice that this are different in comparison to the =elpy= commands
your =C-c C-c= is bounded to in python mode.

In this sense you can achieve the above by starting a different
runtime for each pyhton script using: ~C-u M-x run-python~

Then RET RET until a runtime is created. =python-shell= commands of
the particular script will then be bounded to the runtime. 

With this keyboard binding you can then send the results for each
script to the respective runtime and run multiple runtimes
concurrently.

#+begin_src emacs-lisp 
(define-key python-mode-map (kbd "C-c C-x C-c") 'python-shell-send-region)
(define-key python-mode-map (kbd "C-c C-x C-b") 'python-shell-send-buffer)
#+end_src 

** Code Navigation

 #+begin_src emacs-lisp 
(add-hook 'python-mode-hook 'hs-minor-mode)

;; to remap the default C-c @ that is not available on mac
(define-key hs-minor-mode-map (kbd "C-c M-1") (lookup-key hs-minor-mode-map (kbd "C-c @")))
(define-key hs-minor-mode-map (kbd "C-c @") nil)
 #+end_src 

 Notice that to quickly navigate python code you can use =C-M-a= to go
 to the beginning of the current/previous function and =C-M-e= to go to the end
 of the current/next function.

 Alternative: navigation via =imenu=.

 #+begin_src emacs-lisp 
(defun python-imenu-use-flat-index
    ()
  (setq imenu-create-index-function
        #'python-imenu-create-flat-index))

(add-hook 'python-mode-hook
          #'python-imenu-use-flat-index)
 #+end_src 

** Tabs issues

In org mode I often receive errors because of a mixture of tabs and spaces. This
confuses the python parser. You can solve the issue by using one of the two.

One of the easier solution I could find without loosing to much time on
understanding where the issue arises is to select the block where the error is
present via the shortcut =C-c C-v C-M-h= and subsequently run the =M-x untabify=
command. 

#+begin_src emacs-lisp 
 (global-set-key  (kbd "C-c C-v -") 'untabify)      
#+end_src 


* Language Server

** Config

 *Necessary dependencies:*

 *For Python:* In order to use the python language server you have to install it via
 pip first =pip3 install python-language-server=.

 *For Cpp:* Need clangd in your =PATH=. Install it on Mac via ~brew install llvm~.


 #+begin_src emacs-lisp 
(use-package lsp-mode
  :hook (;; replace XXX-mode with concrete major-mode(e. g. python-mode)
         (python-mode . lsp)

         ;; note not using here as there is some issue. have to use
         ;; clangd compiler but I am using g++ for the project. takes
         ;; to long to fix all of this.  

         ;; (c-mode . lsp) (c++-mode
         ;; . lsp)

         ;; if you want which-key integration
         ;; (lsp-mode . lsp-enable-which-key-integration)
	 )
  :commands lsp
  )
 #+end_src

 #+RESULTS:

 Some config.

 #+begin_src emacs-lisp 
;; company completing
(setq lsp-prefer-capf t)
(setq gc-cons-threshold 100000000)
;; set prefix for lsp-command-keymap (few alternatives - "C-l", "C-c l")
(setq lsp-keymap-prefix "C-c s-l")
 #+end_src 

 #+RESULTS:
 : C-c s-l

 Notice that you have to toggle
 =lsp-ui-sidebar-toggle-symbols-info=. This is a very valuable thing to
 do.

 #+begin_src emacs-lisp 
(use-package lsp-ui
  :custom-face
  (lsp-ui-sideline-code-action ((t (:inherit warning))))
  :hook (lsp-mode . lsp-ui-mode)
  :init (setq lsp-ui-doc-enable t
	      lsp-ui-doc-use-webkit nil
	      lsp-ui-doc-delay 0.5
	      lsp-ui-doc-include-signature t
	      lsp-ui-doc-position 'top
	      lsp-ui-doc-border (face-foreground 'default)
	      lsp-eldoc-enable-hover nil ; Disable eldoc displays in minibuffer

	      lsp-ui-sideline-enable t
	      lsp-ui-sideline-show-hover nil
	      lsp-ui-sideline-show-diagnostics nil
	      lsp-ui-sideline-ignore-duplicate t

	      lsp-ui-imenu-enable t
	      lsp-ui-imenu-colors `(,(face-foreground 'font-lock-keyword-face)
				    ,(face-foreground 'font-lock-string-face)
				    ,(face-foreground 'font-lock-constant-face)
				    ,(face-foreground 'font-lock-variable-name-face)))

  :config
  (add-to-list 'lsp-ui-doc-frame-parameters '(right-fringe . 8))

  ;; `C-g'to close doc
  (advice-add #'keyboard-quit :before #'lsp-ui-doc-hide)

  ;; Reset `lsp-ui-doc-background' after loading theme
  (add-hook 'after-load-theme-hook
	    (lambda ()
	      (setq lsp-ui-doc-border (face-foreground 'default))
	      (set-face-background 'lsp-ui-doc-background
				   (face-background 'tooltip)))))
 #+end_src 

 #+RESULTS:
 | lsp-ui-mode |

 To integrate further and to resolve the issue with python debugging.

 https://github.com/emacsmirror/dap-mode#installation-1

 #+begin_src emacs-lisp 
 (use-package dap-mode
   :quelpa (dap-mode :fetcher github :repo "emacsmirror/dap-mode"))

(require 'dap-python)

  #+end_src 

 Moreover it is possible to integrate the language server with org in
 the editing buffer of =C-'=.

 This was not integrated so far. You can read more about that [[https://github.com/emacs-lsp/lsp-mode/issues/377][here]].

 #+begin_src emacs-lisp 
(defun org-babel-edit-prep:python (babel-info)
  (setq-local buffer-file-name (->> babel-info caddr (alist-get :file-name)))
  (setq-local lsp-buffer-uri (->> babel-info caddr (alist-get :file-name) lsp--path-to-uri))
  (lsp)

    (use-package py-autopep8
      :ensure t)
    (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)

    (pyvenv-mode t) 
    (undo-tree-mode t) 
    (flycheck-mode t)
    (company-mode t)
    (setq venv-location "/Users/marcohassan/Desktop/python_venv")

    ;; Add hook for cÃ²mment highlighting.
    ;;(add-hook 'python-mode-hook 'add-custom-keyw)
  )
 #+end_src 

 Hack for =ein-python=. Transform it to python source block and then open
 the edit buffer. Like this you will have the language server. Then
 when closing it back change the header back to =ein-python=.

 #+begin_src emacs-lisp 
(defun ein_copy_packages ()
 (scimax-ob-jump-to-end)
 (search-backward "ein-python")
 (kill-word 1)
 (delete-char 1)
 (next-line)
 (save-excursion
 (search-backward "#!START_LIB")
 (next-line)
 (beginning-of-line)
 (setq p2 (point))
 (scimax-ob-jump-to-end)
 (previous-line)
 (end-of-line)
 (copy-region-as-kill p2 (point))))


(defun ein_python ()
 (interactive)
 (ein_copy_packages)
 (scimax-ob-jump-to-header)
 (next-line)
 (newline)
 (yank)
 (newline 2)
 (org-edit-special)
)

(defun ein_python_exit ()
 (interactive)
 (goto-char (point-max))
 (search-backward "#!END_LIB")
 (end-of-line)
 (setq p (point))
 (goto-char (point-min))
 (delete-region p (point))
 (kill-line 2)
 (org-edit-src-exit)
 (search-backward "python")
 (insert "ein-")
)

;; map the two to shortcuts
(eval-after-load 'org' (progn 
			 (define-key org-mode-map
			   (kbd "C-c s-'") 'ein_python)
			 (define-key python-mode-map
			   (kbd "C-c s-'") 'ein_python_exit)
			 ))
 #+end_src 

 Super nice with the tangle property. You write all of the chuncks then
 to a single file you can pass as =:tangle= argument.

** Instruction

   Should you be able to leverage this in org chuncks see the
   workaround with the #!START_LIB. Search for it in this file to
   understand that better.


* Which key

#+begin_src emacs-lisp 
(use-package which-key
  :config
  (which-key-mode))
#+end_src 

Advice on the shortcuts available.


* YAML

#+begin_src emacs-lisp 
(use-package yaml-mode
  :ensure t)

(add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
#+end_src 


* Json


#+begin_src emacs-lisp 
(setenv "PATH" (concat (getenv "PATH") ":/Users/marcohassan/.nvm/versions/node/v8.9.0/bin/"))
(setq exec-path (append exec-path '("/Users/marcohassan/.nvm/versions/node/v8.9.0/bin/")))
#+end_src 


#+begin_src emacs-lisp 
(getenv "PATH")
#+end_src 

#+begin_src emacs-lisp 
(use-package json-mode
  :ensure t)

(use-package flymake-easy
  :ensure t)

(use-package flymake-json
  :ensure t)

(global-set-key (kbd "C-c v") 'flymake-json-load)
(add-hook 'json-mode-hook 'flymake-json-load)
#+end_src 


This is a nice option. It will show your json as a tree and you can
observe the structure of the json in there and navigate it in such a
way.

#+begin_src emacs-lisp :async t
(use-package json-navigator
  :ensure t)
#+end_src 

With yafolding you will be able to fold in and out the json documents.

#+begin_src emacs-lisp 
(use-package yafolding
  :quelpa (yafolding :fetcher github :repo "emacsmirror/yafolding")
  :ensure t)
#+end_src 

#+begin_src emacs-lisp 
(add-hook 'json-mode-hook
	    (local-set-key (kbd "C-c h")
			   'yafolding-hide-element)
	    )
#+end_src 


* XML 

Some configuration was taken from [[https://lgfang.github.io/mynotes/emacs/emacs-xml.html#sec-8-1][this link]].
You can refer it if needed.

#+begin_src emacs-lisp 
(add-to-list 'auto-mode-alist
             (cons (concat "\\." (regexp-opt
                                  '("xml") t)
                           "\\'") 'nxml-mode))
(when (> emacs-major-version 21)
  (setq magic-mode-alist3
        (cons '("<\\?xml " . nxml-mode) magic-mode-alist)))
(fset 'xml-mode 'nxml-mode)
(fset 'html-mode 'nxml-mode)
(require 'rng-loc nil t)
#+end_src 

#+begin_src emacs-lisp 
(add-hook 'nxml-mode-hook (lambda() (hs-minor-mode 1)))

(add-to-list 'hs-special-modes-alist
             '(nxml-mode
               "<!--\\|<[^/>]*[^/]>" ;; regexp for starset block
               "-->\\|</[^/>]*[^/]>" ;; regexp for end block
               "<!--"
               nxml-forward-element
               nil))

(defun lgfang-toggle-level ()
  "mainly to be used in nxml mode"
  (interactive) (hs-show-block) (hs-hide-level 1))
#+end_src 

#+begin_src emacs-lisp 
(defun nxml-where ()
  "Display the hierarchy of XML elements the point is on as a path."
  (interactive)
  (let ((path nil))
    (save-excursion
      (save-restriction
        (widen)
        (while (and (< (point-min) (point)) ;; Doesn't error if point is at beginning of buffer
                    (condition-case nil
                        (progn
                          (nxml-backward-up-element) ; always returns nil
                          t)
                      (error nil)))
          (setq path (cons (xmltok-start-tag-local-name) path)))
        (if (called-interactively-p t)
            (message "/%s" (mapconcat 'identity path "/"))
          (format "/%s" (mapconcat 'identity path "/")))))))
#+end_src 


#+begin_src emacs-lisp 
(defun nxml-pretty-print (beg end &optional arg)
  "Reformat the region between BEG and END.
    With optional ARG, also auto-fill."
  (interactive "*r\nP")
  (let ((fill (or (bound-and-true-p auto-fill-function) -1)))
    (sgml-mode)
    (when arg (auto-fill-mode))
    (sgml-pretty-print beg end)
    (nxml-mode)
    (auto-fill-mode fill)))
#+end_src 

Create shortcuts.

#+begin_src emacs-lisp 
;; define keyboard shortcuts for special mode
;; (eval-after-load "nxml-mode"
;;   (progn 
;;      (define-key nxml-mode-map (kbd "C-c C-'") 'lgfang-toggle-level)
;;      (define-key nxml-mode-map (kbd "C-c C-w") 'nxml-where)
;;      (define-key nxml-mode-map  (kbd "C-c C-p") 'nxml-pretty-print)
;;   )
;; )
#+end_src 

Use autocomplete nxml which should be a good autocompletor.

#+begin_src emacs-lisp 
(use-package auto-complete-nxml
  :ensure t)

;; If you want to start completion manually from the beginning
(setq auto-complete-nxml-automatic-p nil)

(add-hook 'nxml-mode-hook 'auto-complete-mode)
#+end_src 


* Inline online images


#+begin_src emacs-lisp 
 (use-package org-yt
   :quelpa (org-yt :fetcher github :repo "TobiasZawada/org-yt"))
 #+end_src 

#+begin_src emacs-lisp 
(require 'org-yt)
#+end_src 

#+begin_src emacs-lisp 
(defun org-image-link (protocol link _description)
  "Interpret LINK as base64-encoded image data."
  (cl-assert (string-match "\\`img" protocol) nil
             "Expected protocol type starting with img")
  (let ((buf (url-retrieve-synchronously (concat (substring protocol 3) ":" link))))
    (cl-assert buf nil
               "Download of image \"%s\" failed." link)
    (with-current-buffer buf
      (goto-char (point-min))
      (re-search-forward "\r?\n\r?\n")
      (buffer-substring-no-properties (point) (point-max)))))

(org-link-set-parameters
 "imghttp"
 :image-data-fun #'org-image-link)

(org-link-set-parameters
 "imghttps"
 :image-data-fun #'org-image-link)
#+end_src 

To use it you have to use the following syntax then. You have to use
=https= if it protected and =http= otherwise.

#+begin_example
[[imghttps  ://bigdataforeng2020.blob.core.windows.net/exercise07/marketplace.png]]
#+end_example


* Quelpa - Dired-Plus Example
   
 #+begin_src emacs-lisp 
 (use-package dired+
   :quelpa (dired+ :fetcher github :repo "emacsmirror/dired-plus"))
 #+end_src 

 #+begin_src emacs-lisp 
 (diredp-toggle-find-file-reuse-dir 1)
 #+end_src 


* PDF viewer

First run on Mac

#+begin_example
$ brew install poppler automake
$ export PKG_CONFIG_PATH=/usr/local/Cellar/zlib/1.2.8/lib/pkgconfig:/usr/local/lib/pkgconfig:/opt/X11/lib/pkgconfig
#+end_example

As on the [[https://github.com/politza/pdf-tools][official webpage]].

#+begin_src emacs-lisp 
;; Then:
;; (use-package pdf-tools
;;   :ensure t
;;   :config
;;   (custom-set-variables
;;     '(pdf-tools-handle-upgrades nil))
;;   (setq pdf-info-epdfinfo-program "/usr/local/bin/epdfinfo"))
#+end_src 


#+begin_src emacs-lisp 
;; (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
#+end_src 

#+begin_src emacs-lisp 
;; Finally:
;; just run it once. Otherwise it asks to rebuild on each start-up
;; (setenv "PKG_CONFIG_PATH" "/usr/local/Cellar/zlib/1.2.8/lib/pkgconfig:/usr/local/lib/pkgconfig:/opt/X11/lib/pkgconfig")
;; (pdf-tools-install)
#+end_src 


* Mac adjustments


#+BEGIN_SRC emacs-lisp
   (if *is-a-mac*
     (add-hook 'after-init-hook
   	    (progn
   	      ;; "fix" the broken keyboard                                        
   	      (global-set-key "\M-1" '(lambda () (interactive) (insert "@")))
   	      (global-set-key "\M-5" '(lambda () (interactive) (insert "[")))
   	      (global-set-key "\M-6" '(lambda () (interactive) (insert "]")))
   	      (global-set-key "\M-7" '(lambda () (interactive) (insert "|")))
   	      (global-set-key "\M-/" '(lambda () (interactive) (insert "\\")))
   	      (global-set-key "\M-8" '(lambda () (interactive) (insert "{")))
   	      (global-set-key "\M-9" '(lambda () (interactive) (insert "}")))
   	      (global-set-key "\M-3" '(lambda () (interactive) (insert "#")))
   	      (global-set-key "\M-2" '(lambda () (interactive) (insert "~"))))))
#+END_SRC


* Shell Configs

** Default Shell

 #+begin_src emacs-lisp 
 (setq explicit-shell-file-name "/bin/bash")
 #+end_src 

 Notice that I have =oh-my-zsh= installed. When I want to use it. I run
 =M-x ansi-term= there you have your nice zsh shell. You can select it
 using /bin/zsh.


** Multi-term

 Nice working well now. I like a lot this shell. Better than all of the
 ones I used so far. Great the integration with =oh-my-zsh=. Look at
 the =.zshrc= there are some configuration that work to set up properly
 =oh-my-zsh= to work with emacs.

 #+begin_src emacs-lisp 
 (use-package multi-term
   :ensure t)
 #+end_src 

 #+begin_src emacs-lisp 
 (setq multi-term-program "/bin/zsh")
 #+end_src 


 #+begin_src emacs-lisp 
 (setq term-bind-key-alist
   '(
     ("C-c C-c" . term-interrupt-subjob)
     ("C-p" . previous-line)
     ("C-n" . next-line)
     ("C-s" . isearch-forward)
     ("C-r" . isearch-backward)
     ("C-m" . term-send-raw)
     ("M-f" . term-send-forward-word)
     ("M-b" . term-send-backward-word)
     ("M-o" . term-send-backspace)
     ("M-p" . term-send-up) ;; go to previous input-
     ("M-n" . term-send-down)
     ("M-d" . term-send-forward-kill-word)
     ("M-w" . term-send-backward-kill-word)
     ("M-r" . term-send-reverse-search-history)
     ("M-," . term-send-input)
     ("M-." . comint-dynamic-complete)))
 #+end_src 

 #+begin_src emacs-lisp 
 (defun term-send-home ()
   (interactive)
   (term-send-raw-string "~"))

 (defun term-curly-open ()
   (interactive)
   (term-send-raw-string "{"))

 (defun term-curly-close ()
   (interactive)
   (term-send-raw-string "}"))

 (defun term-pipe ()
   (interactive)
   (term-send-raw-string "|"))
 #+end_src 

 #+begin_src emacs-lisp 
 (add-to-list 'term-bind-key-alist '("M-2" . term-send-home))
 (add-to-list 'term-bind-key-alist '("M-8" . term-curly-open))
 (add-to-list 'term-bind-key-alist '("M-9" . term-curly-close))
 (add-to-list 'term-bind-key-alist '("M-7" . term-pipe))
 #+end_src 


 #+begin_src emacs-lisp 
 (add-hook 'term-mode-hook
           (lambda ()
             (define-key term-raw-map (kbd "C-y") 'term-paste)))
 #+end_src 

 Notice that an interesting option for the terminal is to go to
 =line-mode= when you want to copy edit stuff. Then you will be able to
 do all the normal operations. You can then switch back to the more
 rigid =char-mode= if you prefer.

 #+begin_src emacs-lisp 
 (add-hook 'term-mode-hook
           (lambda ()
             (define-key term-raw-map (kbd "C-c C-j") 'term-line-mode)))
 (add-hook 'term-mode-hook
           (lambda ()
             (define-key term-raw-map (kbd "C-c C-k") 'term-char-mode)))
 #+end_src 


 #+begin_src emacs-lisp 
 (add-hook 'term-mode-hook
           (lambda ()
             (add-to-list 'term-bind-key-alist '("M-5" . multi-term-prev))
             (add-to-list 'term-bind-key-alist '("M-6" . multi-term-next))))
 #+end_src 


Shortcut to open multi term

#+begin_src emacs-lisp 
(global-set-key (kbd "C-x C-j") 'multi-term)
#+end_src 


** Eshell 

 Fancy Prompt
 #+BEGIN_SRC emacs-lisp
   (defun with-face (str &rest face-plist)
     (propertize str 'face face-plist))

   (defun shk-eshell-prompt ()
     (let ((header-bg "#292929"))   
       (concat
	(with-face (concat (eshell/pwd) " ") :foreground "green")
	(with-face (format-time-string "(%Y-%m-%d %H:%M) " (current-time)) :foreground "#888")
	(with-face
	 (or (ignore-errors (format "(%s)" (vc-responsible-backend default-directory))) ""))
	(with-face "\n")
	(with-face user-login-name :foreground "indian red")
	"@"
	(with-face "localhost" :foreground "sea green")
	(if (= (user-uid) 0)
	    (with-face " #" :foreground "red")
	  " $ "))))

   (setq eshell-prompt-function 'shk-eshell-prompt)
   (setq eshell-highlight-prompt nil)
 #+END_SRC

 A built in solution for search of history commands.

 #+BEGIN_SRC emacs-lisp
   (add-hook 'eshell-mode-hook
	     (lambda ()
	       (local-set-key (kbd "C-c h")
			      (lambda ()
				(interactive)
				(insert
				 (ido-completing-read "Eshell history: "
						      (delete-dups
						       (ring-elements eshell-history-ring))))))
	       ))
 #+END_SRC


** Decide shell to open at start-up

 #+begin_src emacs-lisp 
 (cd "/Users/marcohassan/Desktop/")
 (multi-term)
 (delete-other-windows)
 #+END_SRC


** If you want to start with eshell

 Open Eshell at Start-up

 Eshell is great but if you do not start eshell from within a terminal,
 it has difficulties to run programs listed in the environment PATH.

 Interestingly this fixes the issue just if it is the last statement of
 the emacs configuration file. 

 #+BEGIN_SRC emacs-lisp

 ;; (cd "/Users/marcohassan/Desktop/")
 ;; (eshell)
 ;; (delete-other-windows)
 #+END_SRC


** Open last opened terminal in term mode

 #+begin_src emacs-lisp 
 (defun switch-to-most-recent-terminal ()
   (interactive)
   (let (found)
     (catch 'done
       (mapc (lambda (x)
               (when (with-current-buffer x (eq major-mode 'term-mode))
                 (switch-to-buffer x)
                 (setq found t)
                 (throw 'done nil)))
             (buffer-list))
       (unless found (message "not found")))))
 #+end_src 

 #+begin_src emacs-lisp 
 (global-set-key (kbd "C-c s-s") 'switch-to-most-recent-terminal)
 #+end_src 


* Recognize path on MAC

#+begin_src emacs-lisp 
(use-package exec-path-from-shell
  :ensure t)
;;Later on, after loading exec-path-from-shell package

(if *is-a-mac*
   (add-hook 'after-init-hook 'exec-path-from-shell-initialize))
#+end_src 


* Select theme at start up

#+begin_src emacs-lisp 
(call-interactively 'dark/doom)
#+end_src 


* FIXED Consult when issues

** Org archive

 If you get the error

 =Invalid function: org-preserve-local-variables=

 Then do:

 #+begin_example
  Invalid function: org-preserve-local-variables 
 #+end_example

 Follow the advices [[https://www.reddit.com/r/orgmode/comments/alhuhp/error_archiving/][here]].

 In the specific run

 #+begin_example
 cd ~/.emacs.d/elpa

 find org*/*.elc -print0 | xargs -0 rm
 #+end_example

 Close and reopen emacs.

* TODO IDEAS

** Multi-term

 Open at the beginning a few multi-term displaying processes, network
 utilization etc.

 Inspiration from the pictures on [[https://www.emacswiki.org/emacs/MultiTerm][Multi-term]].

 Nice also the =M-x profiler-start= option with the generated report
 in this sense. 


[[https://emacs.stackexchange.com/questions/2194/how-do-i-force-a-specific-buffer-to-open-in-a-new-window][Open buffer in specific way]]

** TODO fix org-ref pdf download

   [[ref:issue_pdf_downlaod]]

   [[ref:issue_link_at_startup]]


